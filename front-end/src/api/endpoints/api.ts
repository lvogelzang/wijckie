/**
 * Generated by orval v7.10.0 üç∫
 * Do not edit manually.
 * Wijckie API
 * Default API for Wijckie
 * OpenAPI spec version: 1.0.0
 */
import { useMutation, useQuery } from "@tanstack/react-query"
import type {
    DataTag,
    DefinedInitialDataOptions,
    DefinedUseQueryResult,
    MutationFunction,
    QueryClient,
    QueryFunction,
    QueryKey,
    UndefinedInitialDataOptions,
    UseMutationOptions,
    UseMutationResult,
    UseQueryOptions,
    UseQueryResult,
} from "@tanstack/react-query"

import type {
    CreateInspirationOption,
    DefaultOKResponse,
    InspirationModule,
    InspirationModulesListParams,
    InspirationOption,
    InspirationOptionsListParams,
    PaginatedInspirationModuleList,
    PaginatedInspirationOptionList,
    PaginatedUserList,
    PatchedInspirationModule,
    PatchedInspirationOption,
    PatchedUser,
    User,
    UsersListParams,
} from "../models/api"

import { customInstance } from "../../helpers/api"

// https://stackoverflow.com/questions/49579094/typescript-conditional-types-filter-out-readonly-properties-pick-only-requir/49579497#49579497
type IfEquals<X, Y, A = X, B = never> = (<T>() => T extends X ? 1 : 2) extends <T>() => T extends Y ? 1 : 2 ? A : B

type WritableKeys<T> = {
    [P in keyof T]-?: IfEquals<{ [Q in P]: T[P] }, { -readonly [Q in P]: T[P] }, P>
}[keyof T]

type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void ? I : never
type DistributeReadOnlyOverUnions<T> = T extends any ? NonReadonly<T> : never

type Writable<T> = Pick<T, WritableKeys<T>>
type NonReadonly<T> = [T] extends [UnionToIntersection<T>]
    ? {
          [P in keyof Writable<T>]: T[P] extends object ? NonReadonly<NonNullable<T[P]>> : T[P]
      }
    : DistributeReadOnlyOverUnions<T>

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1]

/**
 * Get CSRF token as a cookie.
 */
export const csrfRetrieve = (options?: SecondParameter<typeof customInstance>, signal?: AbortSignal) => {
    return customInstance<DefaultOKResponse>({ url: `/api/v1/csrf/`, method: "GET", signal }, options)
}

export const getCsrfRetrieveQueryKey = () => {
    return [`/api/v1/csrf/`] as const
}

export const getCsrfRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof csrfRetrieve>>, TError = unknown>(options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof csrfRetrieve>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
}) => {
    const { query: queryOptions, request: requestOptions } = options ?? {}

    const queryKey = queryOptions?.queryKey ?? getCsrfRetrieveQueryKey()

    const queryFn: QueryFunction<Awaited<ReturnType<typeof csrfRetrieve>>> = ({ signal }) => csrfRetrieve(requestOptions, signal)

    return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<Awaited<ReturnType<typeof csrfRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CsrfRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof csrfRetrieve>>>
export type CsrfRetrieveQueryError = unknown

export function useCsrfRetrieve<TData = Awaited<ReturnType<typeof csrfRetrieve>>, TError = unknown>(
    options: {
        query: Partial<UseQueryOptions<Awaited<ReturnType<typeof csrfRetrieve>>, TError, TData>> &
            Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof csrfRetrieve>>, TError, Awaited<ReturnType<typeof csrfRetrieve>>>, "initialData">
        request?: SecondParameter<typeof customInstance>
    },
    queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCsrfRetrieve<TData = Awaited<ReturnType<typeof csrfRetrieve>>, TError = unknown>(
    options?: {
        query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof csrfRetrieve>>, TError, TData>> &
            Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof csrfRetrieve>>, TError, Awaited<ReturnType<typeof csrfRetrieve>>>, "initialData">
        request?: SecondParameter<typeof customInstance>
    },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCsrfRetrieve<TData = Awaited<ReturnType<typeof csrfRetrieve>>, TError = unknown>(
    options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof csrfRetrieve>>, TError, TData>>; request?: SecondParameter<typeof customInstance> },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useCsrfRetrieve<TData = Awaited<ReturnType<typeof csrfRetrieve>>, TError = unknown>(
    options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof csrfRetrieve>>, TError, TData>>; request?: SecondParameter<typeof customInstance> },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
    const queryOptions = getCsrfRetrieveQueryOptions(options)

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

    query.queryKey = queryOptions.queryKey

    return query
}

export const inspirationModulesList = (params?: InspirationModulesListParams, options?: SecondParameter<typeof customInstance>, signal?: AbortSignal) => {
    return customInstance<PaginatedInspirationModuleList>({ url: `/api/v1/inspiration-modules/`, method: "GET", params, signal }, options)
}

export const getInspirationModulesListQueryKey = (params?: InspirationModulesListParams) => {
    return [`/api/v1/inspiration-modules/`, ...(params ? [params] : [])] as const
}

export const getInspirationModulesListQueryOptions = <TData = Awaited<ReturnType<typeof inspirationModulesList>>, TError = unknown>(
    params?: InspirationModulesListParams,
    options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof inspirationModulesList>>, TError, TData>>; request?: SecondParameter<typeof customInstance> }
) => {
    const { query: queryOptions, request: requestOptions } = options ?? {}

    const queryKey = queryOptions?.queryKey ?? getInspirationModulesListQueryKey(params)

    const queryFn: QueryFunction<Awaited<ReturnType<typeof inspirationModulesList>>> = ({ signal }) => inspirationModulesList(params, requestOptions, signal)

    return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<Awaited<ReturnType<typeof inspirationModulesList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type InspirationModulesListQueryResult = NonNullable<Awaited<ReturnType<typeof inspirationModulesList>>>
export type InspirationModulesListQueryError = unknown

export function useInspirationModulesList<TData = Awaited<ReturnType<typeof inspirationModulesList>>, TError = unknown>(
    params: undefined | InspirationModulesListParams,
    options: {
        query: Partial<UseQueryOptions<Awaited<ReturnType<typeof inspirationModulesList>>, TError, TData>> &
            Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof inspirationModulesList>>, TError, Awaited<ReturnType<typeof inspirationModulesList>>>, "initialData">
        request?: SecondParameter<typeof customInstance>
    },
    queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useInspirationModulesList<TData = Awaited<ReturnType<typeof inspirationModulesList>>, TError = unknown>(
    params?: InspirationModulesListParams,
    options?: {
        query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof inspirationModulesList>>, TError, TData>> &
            Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof inspirationModulesList>>, TError, Awaited<ReturnType<typeof inspirationModulesList>>>, "initialData">
        request?: SecondParameter<typeof customInstance>
    },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useInspirationModulesList<TData = Awaited<ReturnType<typeof inspirationModulesList>>, TError = unknown>(
    params?: InspirationModulesListParams,
    options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof inspirationModulesList>>, TError, TData>>; request?: SecondParameter<typeof customInstance> },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useInspirationModulesList<TData = Awaited<ReturnType<typeof inspirationModulesList>>, TError = unknown>(
    params?: InspirationModulesListParams,
    options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof inspirationModulesList>>, TError, TData>>; request?: SecondParameter<typeof customInstance> },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
    const queryOptions = getInspirationModulesListQueryOptions(params, options)

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

    query.queryKey = queryOptions.queryKey

    return query
}

export const inspirationModulesCreate = (inspirationModule: NonReadonly<InspirationModule>, options?: SecondParameter<typeof customInstance>, signal?: AbortSignal) => {
    return customInstance<InspirationModule>({ url: `/api/v1/inspiration-modules/`, method: "POST", headers: { "Content-Type": "application/json" }, data: inspirationModule, signal }, options)
}

export const getInspirationModulesCreateMutationOptions = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof inspirationModulesCreate>>, TError, { data: NonReadonly<InspirationModule> }, TContext>
    request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<Awaited<ReturnType<typeof inspirationModulesCreate>>, TError, { data: NonReadonly<InspirationModule> }, TContext> => {
    const mutationKey = ["inspirationModulesCreate"]
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined }

    const mutationFn: MutationFunction<Awaited<ReturnType<typeof inspirationModulesCreate>>, { data: NonReadonly<InspirationModule> }> = (props) => {
        const { data } = props ?? {}

        return inspirationModulesCreate(data, requestOptions)
    }

    return { mutationFn, ...mutationOptions }
}

export type InspirationModulesCreateMutationResult = NonNullable<Awaited<ReturnType<typeof inspirationModulesCreate>>>
export type InspirationModulesCreateMutationBody = NonReadonly<InspirationModule>
export type InspirationModulesCreateMutationError = unknown

export const useInspirationModulesCreate = <TError = unknown, TContext = unknown>(
    options?: {
        mutation?: UseMutationOptions<Awaited<ReturnType<typeof inspirationModulesCreate>>, TError, { data: NonReadonly<InspirationModule> }, TContext>
        request?: SecondParameter<typeof customInstance>
    },
    queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof inspirationModulesCreate>>, TError, { data: NonReadonly<InspirationModule> }, TContext> => {
    const mutationOptions = getInspirationModulesCreateMutationOptions(options)

    return useMutation(mutationOptions, queryClient)
}

export const inspirationModulesRetrieve = (id: number, options?: SecondParameter<typeof customInstance>, signal?: AbortSignal) => {
    return customInstance<InspirationModule>({ url: `/api/v1/inspiration-modules/${id}/`, method: "GET", signal }, options)
}

export const getInspirationModulesRetrieveQueryKey = (id: number) => {
    return [`/api/v1/inspiration-modules/${id}/`] as const
}

export const getInspirationModulesRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof inspirationModulesRetrieve>>, TError = unknown>(
    id: number,
    options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof inspirationModulesRetrieve>>, TError, TData>>; request?: SecondParameter<typeof customInstance> }
) => {
    const { query: queryOptions, request: requestOptions } = options ?? {}

    const queryKey = queryOptions?.queryKey ?? getInspirationModulesRetrieveQueryKey(id)

    const queryFn: QueryFunction<Awaited<ReturnType<typeof inspirationModulesRetrieve>>> = ({ signal }) => inspirationModulesRetrieve(id, requestOptions, signal)

    return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<Awaited<ReturnType<typeof inspirationModulesRetrieve>>, TError, TData> & {
        queryKey: DataTag<QueryKey, TData, TError>
    }
}

export type InspirationModulesRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof inspirationModulesRetrieve>>>
export type InspirationModulesRetrieveQueryError = unknown

export function useInspirationModulesRetrieve<TData = Awaited<ReturnType<typeof inspirationModulesRetrieve>>, TError = unknown>(
    id: number,
    options: {
        query: Partial<UseQueryOptions<Awaited<ReturnType<typeof inspirationModulesRetrieve>>, TError, TData>> &
            Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof inspirationModulesRetrieve>>, TError, Awaited<ReturnType<typeof inspirationModulesRetrieve>>>, "initialData">
        request?: SecondParameter<typeof customInstance>
    },
    queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useInspirationModulesRetrieve<TData = Awaited<ReturnType<typeof inspirationModulesRetrieve>>, TError = unknown>(
    id: number,
    options?: {
        query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof inspirationModulesRetrieve>>, TError, TData>> &
            Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof inspirationModulesRetrieve>>, TError, Awaited<ReturnType<typeof inspirationModulesRetrieve>>>, "initialData">
        request?: SecondParameter<typeof customInstance>
    },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useInspirationModulesRetrieve<TData = Awaited<ReturnType<typeof inspirationModulesRetrieve>>, TError = unknown>(
    id: number,
    options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof inspirationModulesRetrieve>>, TError, TData>>; request?: SecondParameter<typeof customInstance> },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useInspirationModulesRetrieve<TData = Awaited<ReturnType<typeof inspirationModulesRetrieve>>, TError = unknown>(
    id: number,
    options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof inspirationModulesRetrieve>>, TError, TData>>; request?: SecondParameter<typeof customInstance> },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
    const queryOptions = getInspirationModulesRetrieveQueryOptions(id, options)

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

    query.queryKey = queryOptions.queryKey

    return query
}

export const inspirationModulesUpdate = (id: number, inspirationModule: NonReadonly<InspirationModule>, options?: SecondParameter<typeof customInstance>) => {
    return customInstance<InspirationModule>({ url: `/api/v1/inspiration-modules/${id}/`, method: "PUT", headers: { "Content-Type": "application/json" }, data: inspirationModule }, options)
}

export const getInspirationModulesUpdateMutationOptions = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof inspirationModulesUpdate>>, TError, { id: number; data: NonReadonly<InspirationModule> }, TContext>
    request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<Awaited<ReturnType<typeof inspirationModulesUpdate>>, TError, { id: number; data: NonReadonly<InspirationModule> }, TContext> => {
    const mutationKey = ["inspirationModulesUpdate"]
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined }

    const mutationFn: MutationFunction<Awaited<ReturnType<typeof inspirationModulesUpdate>>, { id: number; data: NonReadonly<InspirationModule> }> = (props) => {
        const { id, data } = props ?? {}

        return inspirationModulesUpdate(id, data, requestOptions)
    }

    return { mutationFn, ...mutationOptions }
}

export type InspirationModulesUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof inspirationModulesUpdate>>>
export type InspirationModulesUpdateMutationBody = NonReadonly<InspirationModule>
export type InspirationModulesUpdateMutationError = unknown

export const useInspirationModulesUpdate = <TError = unknown, TContext = unknown>(
    options?: {
        mutation?: UseMutationOptions<Awaited<ReturnType<typeof inspirationModulesUpdate>>, TError, { id: number; data: NonReadonly<InspirationModule> }, TContext>
        request?: SecondParameter<typeof customInstance>
    },
    queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof inspirationModulesUpdate>>, TError, { id: number; data: NonReadonly<InspirationModule> }, TContext> => {
    const mutationOptions = getInspirationModulesUpdateMutationOptions(options)

    return useMutation(mutationOptions, queryClient)
}

export const inspirationModulesPartialUpdate = (id: number, patchedInspirationModule: NonReadonly<PatchedInspirationModule>, options?: SecondParameter<typeof customInstance>) => {
    return customInstance<InspirationModule>({ url: `/api/v1/inspiration-modules/${id}/`, method: "PATCH", headers: { "Content-Type": "application/json" }, data: patchedInspirationModule }, options)
}

export const getInspirationModulesPartialUpdateMutationOptions = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof inspirationModulesPartialUpdate>>, TError, { id: number; data: NonReadonly<PatchedInspirationModule> }, TContext>
    request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<Awaited<ReturnType<typeof inspirationModulesPartialUpdate>>, TError, { id: number; data: NonReadonly<PatchedInspirationModule> }, TContext> => {
    const mutationKey = ["inspirationModulesPartialUpdate"]
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined }

    const mutationFn: MutationFunction<Awaited<ReturnType<typeof inspirationModulesPartialUpdate>>, { id: number; data: NonReadonly<PatchedInspirationModule> }> = (props) => {
        const { id, data } = props ?? {}

        return inspirationModulesPartialUpdate(id, data, requestOptions)
    }

    return { mutationFn, ...mutationOptions }
}

export type InspirationModulesPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof inspirationModulesPartialUpdate>>>
export type InspirationModulesPartialUpdateMutationBody = NonReadonly<PatchedInspirationModule>
export type InspirationModulesPartialUpdateMutationError = unknown

export const useInspirationModulesPartialUpdate = <TError = unknown, TContext = unknown>(
    options?: {
        mutation?: UseMutationOptions<Awaited<ReturnType<typeof inspirationModulesPartialUpdate>>, TError, { id: number; data: NonReadonly<PatchedInspirationModule> }, TContext>
        request?: SecondParameter<typeof customInstance>
    },
    queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof inspirationModulesPartialUpdate>>, TError, { id: number; data: NonReadonly<PatchedInspirationModule> }, TContext> => {
    const mutationOptions = getInspirationModulesPartialUpdateMutationOptions(options)

    return useMutation(mutationOptions, queryClient)
}

export const inspirationModulesDestroy = (id: number, options?: SecondParameter<typeof customInstance>) => {
    return customInstance<void>({ url: `/api/v1/inspiration-modules/${id}/`, method: "DELETE" }, options)
}

export const getInspirationModulesDestroyMutationOptions = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof inspirationModulesDestroy>>, TError, { id: number }, TContext>
    request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<Awaited<ReturnType<typeof inspirationModulesDestroy>>, TError, { id: number }, TContext> => {
    const mutationKey = ["inspirationModulesDestroy"]
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined }

    const mutationFn: MutationFunction<Awaited<ReturnType<typeof inspirationModulesDestroy>>, { id: number }> = (props) => {
        const { id } = props ?? {}

        return inspirationModulesDestroy(id, requestOptions)
    }

    return { mutationFn, ...mutationOptions }
}

export type InspirationModulesDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof inspirationModulesDestroy>>>

export type InspirationModulesDestroyMutationError = unknown

export const useInspirationModulesDestroy = <TError = unknown, TContext = unknown>(
    options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof inspirationModulesDestroy>>, TError, { id: number }, TContext>; request?: SecondParameter<typeof customInstance> },
    queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof inspirationModulesDestroy>>, TError, { id: number }, TContext> => {
    const mutationOptions = getInspirationModulesDestroyMutationOptions(options)

    return useMutation(mutationOptions, queryClient)
}

export const inspirationOptionsList = (params?: InspirationOptionsListParams, options?: SecondParameter<typeof customInstance>, signal?: AbortSignal) => {
    return customInstance<PaginatedInspirationOptionList>({ url: `/api/v1/inspiration-options/`, method: "GET", params, signal }, options)
}

export const getInspirationOptionsListQueryKey = (params?: InspirationOptionsListParams) => {
    return [`/api/v1/inspiration-options/`, ...(params ? [params] : [])] as const
}

export const getInspirationOptionsListQueryOptions = <TData = Awaited<ReturnType<typeof inspirationOptionsList>>, TError = unknown>(
    params?: InspirationOptionsListParams,
    options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof inspirationOptionsList>>, TError, TData>>; request?: SecondParameter<typeof customInstance> }
) => {
    const { query: queryOptions, request: requestOptions } = options ?? {}

    const queryKey = queryOptions?.queryKey ?? getInspirationOptionsListQueryKey(params)

    const queryFn: QueryFunction<Awaited<ReturnType<typeof inspirationOptionsList>>> = ({ signal }) => inspirationOptionsList(params, requestOptions, signal)

    return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<Awaited<ReturnType<typeof inspirationOptionsList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type InspirationOptionsListQueryResult = NonNullable<Awaited<ReturnType<typeof inspirationOptionsList>>>
export type InspirationOptionsListQueryError = unknown

export function useInspirationOptionsList<TData = Awaited<ReturnType<typeof inspirationOptionsList>>, TError = unknown>(
    params: undefined | InspirationOptionsListParams,
    options: {
        query: Partial<UseQueryOptions<Awaited<ReturnType<typeof inspirationOptionsList>>, TError, TData>> &
            Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof inspirationOptionsList>>, TError, Awaited<ReturnType<typeof inspirationOptionsList>>>, "initialData">
        request?: SecondParameter<typeof customInstance>
    },
    queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useInspirationOptionsList<TData = Awaited<ReturnType<typeof inspirationOptionsList>>, TError = unknown>(
    params?: InspirationOptionsListParams,
    options?: {
        query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof inspirationOptionsList>>, TError, TData>> &
            Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof inspirationOptionsList>>, TError, Awaited<ReturnType<typeof inspirationOptionsList>>>, "initialData">
        request?: SecondParameter<typeof customInstance>
    },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useInspirationOptionsList<TData = Awaited<ReturnType<typeof inspirationOptionsList>>, TError = unknown>(
    params?: InspirationOptionsListParams,
    options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof inspirationOptionsList>>, TError, TData>>; request?: SecondParameter<typeof customInstance> },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useInspirationOptionsList<TData = Awaited<ReturnType<typeof inspirationOptionsList>>, TError = unknown>(
    params?: InspirationOptionsListParams,
    options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof inspirationOptionsList>>, TError, TData>>; request?: SecondParameter<typeof customInstance> },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
    const queryOptions = getInspirationOptionsListQueryOptions(params, options)

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

    query.queryKey = queryOptions.queryKey

    return query
}

export const inspirationOptionsCreate = (createInspirationOption: NonReadonly<CreateInspirationOption>, options?: SecondParameter<typeof customInstance>, signal?: AbortSignal) => {
    return customInstance<CreateInspirationOption>(
        { url: `/api/v1/inspiration-options/`, method: "POST", headers: { "Content-Type": "application/json" }, data: createInspirationOption, signal },
        options
    )
}

export const getInspirationOptionsCreateMutationOptions = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof inspirationOptionsCreate>>, TError, { data: NonReadonly<CreateInspirationOption> }, TContext>
    request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<Awaited<ReturnType<typeof inspirationOptionsCreate>>, TError, { data: NonReadonly<CreateInspirationOption> }, TContext> => {
    const mutationKey = ["inspirationOptionsCreate"]
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined }

    const mutationFn: MutationFunction<Awaited<ReturnType<typeof inspirationOptionsCreate>>, { data: NonReadonly<CreateInspirationOption> }> = (props) => {
        const { data } = props ?? {}

        return inspirationOptionsCreate(data, requestOptions)
    }

    return { mutationFn, ...mutationOptions }
}

export type InspirationOptionsCreateMutationResult = NonNullable<Awaited<ReturnType<typeof inspirationOptionsCreate>>>
export type InspirationOptionsCreateMutationBody = NonReadonly<CreateInspirationOption>
export type InspirationOptionsCreateMutationError = unknown

export const useInspirationOptionsCreate = <TError = unknown, TContext = unknown>(
    options?: {
        mutation?: UseMutationOptions<Awaited<ReturnType<typeof inspirationOptionsCreate>>, TError, { data: NonReadonly<CreateInspirationOption> }, TContext>
        request?: SecondParameter<typeof customInstance>
    },
    queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof inspirationOptionsCreate>>, TError, { data: NonReadonly<CreateInspirationOption> }, TContext> => {
    const mutationOptions = getInspirationOptionsCreateMutationOptions(options)

    return useMutation(mutationOptions, queryClient)
}

export const inspirationOptionsRetrieve = (id: number, options?: SecondParameter<typeof customInstance>, signal?: AbortSignal) => {
    return customInstance<InspirationOption>({ url: `/api/v1/inspiration-options/${id}/`, method: "GET", signal }, options)
}

export const getInspirationOptionsRetrieveQueryKey = (id: number) => {
    return [`/api/v1/inspiration-options/${id}/`] as const
}

export const getInspirationOptionsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof inspirationOptionsRetrieve>>, TError = unknown>(
    id: number,
    options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof inspirationOptionsRetrieve>>, TError, TData>>; request?: SecondParameter<typeof customInstance> }
) => {
    const { query: queryOptions, request: requestOptions } = options ?? {}

    const queryKey = queryOptions?.queryKey ?? getInspirationOptionsRetrieveQueryKey(id)

    const queryFn: QueryFunction<Awaited<ReturnType<typeof inspirationOptionsRetrieve>>> = ({ signal }) => inspirationOptionsRetrieve(id, requestOptions, signal)

    return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<Awaited<ReturnType<typeof inspirationOptionsRetrieve>>, TError, TData> & {
        queryKey: DataTag<QueryKey, TData, TError>
    }
}

export type InspirationOptionsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof inspirationOptionsRetrieve>>>
export type InspirationOptionsRetrieveQueryError = unknown

export function useInspirationOptionsRetrieve<TData = Awaited<ReturnType<typeof inspirationOptionsRetrieve>>, TError = unknown>(
    id: number,
    options: {
        query: Partial<UseQueryOptions<Awaited<ReturnType<typeof inspirationOptionsRetrieve>>, TError, TData>> &
            Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof inspirationOptionsRetrieve>>, TError, Awaited<ReturnType<typeof inspirationOptionsRetrieve>>>, "initialData">
        request?: SecondParameter<typeof customInstance>
    },
    queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useInspirationOptionsRetrieve<TData = Awaited<ReturnType<typeof inspirationOptionsRetrieve>>, TError = unknown>(
    id: number,
    options?: {
        query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof inspirationOptionsRetrieve>>, TError, TData>> &
            Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof inspirationOptionsRetrieve>>, TError, Awaited<ReturnType<typeof inspirationOptionsRetrieve>>>, "initialData">
        request?: SecondParameter<typeof customInstance>
    },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useInspirationOptionsRetrieve<TData = Awaited<ReturnType<typeof inspirationOptionsRetrieve>>, TError = unknown>(
    id: number,
    options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof inspirationOptionsRetrieve>>, TError, TData>>; request?: SecondParameter<typeof customInstance> },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useInspirationOptionsRetrieve<TData = Awaited<ReturnType<typeof inspirationOptionsRetrieve>>, TError = unknown>(
    id: number,
    options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof inspirationOptionsRetrieve>>, TError, TData>>; request?: SecondParameter<typeof customInstance> },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
    const queryOptions = getInspirationOptionsRetrieveQueryOptions(id, options)

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

    query.queryKey = queryOptions.queryKey

    return query
}

export const inspirationOptionsUpdate = (id: number, inspirationOption: NonReadonly<InspirationOption>, options?: SecondParameter<typeof customInstance>) => {
    return customInstance<InspirationOption>({ url: `/api/v1/inspiration-options/${id}/`, method: "PUT", headers: { "Content-Type": "application/json" }, data: inspirationOption }, options)
}

export const getInspirationOptionsUpdateMutationOptions = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof inspirationOptionsUpdate>>, TError, { id: number; data: NonReadonly<InspirationOption> }, TContext>
    request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<Awaited<ReturnType<typeof inspirationOptionsUpdate>>, TError, { id: number; data: NonReadonly<InspirationOption> }, TContext> => {
    const mutationKey = ["inspirationOptionsUpdate"]
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined }

    const mutationFn: MutationFunction<Awaited<ReturnType<typeof inspirationOptionsUpdate>>, { id: number; data: NonReadonly<InspirationOption> }> = (props) => {
        const { id, data } = props ?? {}

        return inspirationOptionsUpdate(id, data, requestOptions)
    }

    return { mutationFn, ...mutationOptions }
}

export type InspirationOptionsUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof inspirationOptionsUpdate>>>
export type InspirationOptionsUpdateMutationBody = NonReadonly<InspirationOption>
export type InspirationOptionsUpdateMutationError = unknown

export const useInspirationOptionsUpdate = <TError = unknown, TContext = unknown>(
    options?: {
        mutation?: UseMutationOptions<Awaited<ReturnType<typeof inspirationOptionsUpdate>>, TError, { id: number; data: NonReadonly<InspirationOption> }, TContext>
        request?: SecondParameter<typeof customInstance>
    },
    queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof inspirationOptionsUpdate>>, TError, { id: number; data: NonReadonly<InspirationOption> }, TContext> => {
    const mutationOptions = getInspirationOptionsUpdateMutationOptions(options)

    return useMutation(mutationOptions, queryClient)
}

export const inspirationOptionsPartialUpdate = (id: number, patchedInspirationOption: NonReadonly<PatchedInspirationOption>, options?: SecondParameter<typeof customInstance>) => {
    return customInstance<InspirationOption>({ url: `/api/v1/inspiration-options/${id}/`, method: "PATCH", headers: { "Content-Type": "application/json" }, data: patchedInspirationOption }, options)
}

export const getInspirationOptionsPartialUpdateMutationOptions = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof inspirationOptionsPartialUpdate>>, TError, { id: number; data: NonReadonly<PatchedInspirationOption> }, TContext>
    request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<Awaited<ReturnType<typeof inspirationOptionsPartialUpdate>>, TError, { id: number; data: NonReadonly<PatchedInspirationOption> }, TContext> => {
    const mutationKey = ["inspirationOptionsPartialUpdate"]
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined }

    const mutationFn: MutationFunction<Awaited<ReturnType<typeof inspirationOptionsPartialUpdate>>, { id: number; data: NonReadonly<PatchedInspirationOption> }> = (props) => {
        const { id, data } = props ?? {}

        return inspirationOptionsPartialUpdate(id, data, requestOptions)
    }

    return { mutationFn, ...mutationOptions }
}

export type InspirationOptionsPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof inspirationOptionsPartialUpdate>>>
export type InspirationOptionsPartialUpdateMutationBody = NonReadonly<PatchedInspirationOption>
export type InspirationOptionsPartialUpdateMutationError = unknown

export const useInspirationOptionsPartialUpdate = <TError = unknown, TContext = unknown>(
    options?: {
        mutation?: UseMutationOptions<Awaited<ReturnType<typeof inspirationOptionsPartialUpdate>>, TError, { id: number; data: NonReadonly<PatchedInspirationOption> }, TContext>
        request?: SecondParameter<typeof customInstance>
    },
    queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof inspirationOptionsPartialUpdate>>, TError, { id: number; data: NonReadonly<PatchedInspirationOption> }, TContext> => {
    const mutationOptions = getInspirationOptionsPartialUpdateMutationOptions(options)

    return useMutation(mutationOptions, queryClient)
}

export const inspirationOptionsDestroy = (id: number, options?: SecondParameter<typeof customInstance>) => {
    return customInstance<void>({ url: `/api/v1/inspiration-options/${id}/`, method: "DELETE" }, options)
}

export const getInspirationOptionsDestroyMutationOptions = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof inspirationOptionsDestroy>>, TError, { id: number }, TContext>
    request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<Awaited<ReturnType<typeof inspirationOptionsDestroy>>, TError, { id: number }, TContext> => {
    const mutationKey = ["inspirationOptionsDestroy"]
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined }

    const mutationFn: MutationFunction<Awaited<ReturnType<typeof inspirationOptionsDestroy>>, { id: number }> = (props) => {
        const { id } = props ?? {}

        return inspirationOptionsDestroy(id, requestOptions)
    }

    return { mutationFn, ...mutationOptions }
}

export type InspirationOptionsDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof inspirationOptionsDestroy>>>

export type InspirationOptionsDestroyMutationError = unknown

export const useInspirationOptionsDestroy = <TError = unknown, TContext = unknown>(
    options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof inspirationOptionsDestroy>>, TError, { id: number }, TContext>; request?: SecondParameter<typeof customInstance> },
    queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof inspirationOptionsDestroy>>, TError, { id: number }, TContext> => {
    const mutationOptions = getInspirationOptionsDestroyMutationOptions(options)

    return useMutation(mutationOptions, queryClient)
}

export const usersList = (params?: UsersListParams, options?: SecondParameter<typeof customInstance>, signal?: AbortSignal) => {
    return customInstance<PaginatedUserList>({ url: `/api/v1/users/`, method: "GET", params, signal }, options)
}

export const getUsersListQueryKey = (params?: UsersListParams) => {
    return [`/api/v1/users/`, ...(params ? [params] : [])] as const
}

export const getUsersListQueryOptions = <TData = Awaited<ReturnType<typeof usersList>>, TError = unknown>(
    params?: UsersListParams,
    options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof usersList>>, TError, TData>>; request?: SecondParameter<typeof customInstance> }
) => {
    const { query: queryOptions, request: requestOptions } = options ?? {}

    const queryKey = queryOptions?.queryKey ?? getUsersListQueryKey(params)

    const queryFn: QueryFunction<Awaited<ReturnType<typeof usersList>>> = ({ signal }) => usersList(params, requestOptions, signal)

    return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<Awaited<ReturnType<typeof usersList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type UsersListQueryResult = NonNullable<Awaited<ReturnType<typeof usersList>>>
export type UsersListQueryError = unknown

export function useUsersList<TData = Awaited<ReturnType<typeof usersList>>, TError = unknown>(
    params: undefined | UsersListParams,
    options: {
        query: Partial<UseQueryOptions<Awaited<ReturnType<typeof usersList>>, TError, TData>> &
            Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof usersList>>, TError, Awaited<ReturnType<typeof usersList>>>, "initialData">
        request?: SecondParameter<typeof customInstance>
    },
    queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUsersList<TData = Awaited<ReturnType<typeof usersList>>, TError = unknown>(
    params?: UsersListParams,
    options?: {
        query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof usersList>>, TError, TData>> &
            Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof usersList>>, TError, Awaited<ReturnType<typeof usersList>>>, "initialData">
        request?: SecondParameter<typeof customInstance>
    },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUsersList<TData = Awaited<ReturnType<typeof usersList>>, TError = unknown>(
    params?: UsersListParams,
    options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof usersList>>, TError, TData>>; request?: SecondParameter<typeof customInstance> },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useUsersList<TData = Awaited<ReturnType<typeof usersList>>, TError = unknown>(
    params?: UsersListParams,
    options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof usersList>>, TError, TData>>; request?: SecondParameter<typeof customInstance> },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
    const queryOptions = getUsersListQueryOptions(params, options)

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

    query.queryKey = queryOptions.queryKey

    return query
}

export const usersCreate = (user: NonReadonly<User>, options?: SecondParameter<typeof customInstance>, signal?: AbortSignal) => {
    return customInstance<User>({ url: `/api/v1/users/`, method: "POST", headers: { "Content-Type": "application/json" }, data: user, signal }, options)
}

export const getUsersCreateMutationOptions = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof usersCreate>>, TError, { data: NonReadonly<User> }, TContext>
    request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<Awaited<ReturnType<typeof usersCreate>>, TError, { data: NonReadonly<User> }, TContext> => {
    const mutationKey = ["usersCreate"]
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined }

    const mutationFn: MutationFunction<Awaited<ReturnType<typeof usersCreate>>, { data: NonReadonly<User> }> = (props) => {
        const { data } = props ?? {}

        return usersCreate(data, requestOptions)
    }

    return { mutationFn, ...mutationOptions }
}

export type UsersCreateMutationResult = NonNullable<Awaited<ReturnType<typeof usersCreate>>>
export type UsersCreateMutationBody = NonReadonly<User>
export type UsersCreateMutationError = unknown

export const useUsersCreate = <TError = unknown, TContext = unknown>(
    options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof usersCreate>>, TError, { data: NonReadonly<User> }, TContext>; request?: SecondParameter<typeof customInstance> },
    queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof usersCreate>>, TError, { data: NonReadonly<User> }, TContext> => {
    const mutationOptions = getUsersCreateMutationOptions(options)

    return useMutation(mutationOptions, queryClient)
}

export const usersRetrieve = (id: number, options?: SecondParameter<typeof customInstance>, signal?: AbortSignal) => {
    return customInstance<User>({ url: `/api/v1/users/${id}/`, method: "GET", signal }, options)
}

export const getUsersRetrieveQueryKey = (id: number) => {
    return [`/api/v1/users/${id}/`] as const
}

export const getUsersRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof usersRetrieve>>, TError = unknown>(
    id: number,
    options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof usersRetrieve>>, TError, TData>>; request?: SecondParameter<typeof customInstance> }
) => {
    const { query: queryOptions, request: requestOptions } = options ?? {}

    const queryKey = queryOptions?.queryKey ?? getUsersRetrieveQueryKey(id)

    const queryFn: QueryFunction<Awaited<ReturnType<typeof usersRetrieve>>> = ({ signal }) => usersRetrieve(id, requestOptions, signal)

    return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<Awaited<ReturnType<typeof usersRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type UsersRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof usersRetrieve>>>
export type UsersRetrieveQueryError = unknown

export function useUsersRetrieve<TData = Awaited<ReturnType<typeof usersRetrieve>>, TError = unknown>(
    id: number,
    options: {
        query: Partial<UseQueryOptions<Awaited<ReturnType<typeof usersRetrieve>>, TError, TData>> &
            Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof usersRetrieve>>, TError, Awaited<ReturnType<typeof usersRetrieve>>>, "initialData">
        request?: SecondParameter<typeof customInstance>
    },
    queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUsersRetrieve<TData = Awaited<ReturnType<typeof usersRetrieve>>, TError = unknown>(
    id: number,
    options?: {
        query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof usersRetrieve>>, TError, TData>> &
            Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof usersRetrieve>>, TError, Awaited<ReturnType<typeof usersRetrieve>>>, "initialData">
        request?: SecondParameter<typeof customInstance>
    },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUsersRetrieve<TData = Awaited<ReturnType<typeof usersRetrieve>>, TError = unknown>(
    id: number,
    options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof usersRetrieve>>, TError, TData>>; request?: SecondParameter<typeof customInstance> },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useUsersRetrieve<TData = Awaited<ReturnType<typeof usersRetrieve>>, TError = unknown>(
    id: number,
    options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof usersRetrieve>>, TError, TData>>; request?: SecondParameter<typeof customInstance> },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
    const queryOptions = getUsersRetrieveQueryOptions(id, options)

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

    query.queryKey = queryOptions.queryKey

    return query
}

export const usersUpdate = (id: number, user: NonReadonly<User>, options?: SecondParameter<typeof customInstance>) => {
    return customInstance<User>({ url: `/api/v1/users/${id}/`, method: "PUT", headers: { "Content-Type": "application/json" }, data: user }, options)
}

export const getUsersUpdateMutationOptions = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof usersUpdate>>, TError, { id: number; data: NonReadonly<User> }, TContext>
    request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<Awaited<ReturnType<typeof usersUpdate>>, TError, { id: number; data: NonReadonly<User> }, TContext> => {
    const mutationKey = ["usersUpdate"]
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined }

    const mutationFn: MutationFunction<Awaited<ReturnType<typeof usersUpdate>>, { id: number; data: NonReadonly<User> }> = (props) => {
        const { id, data } = props ?? {}

        return usersUpdate(id, data, requestOptions)
    }

    return { mutationFn, ...mutationOptions }
}

export type UsersUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof usersUpdate>>>
export type UsersUpdateMutationBody = NonReadonly<User>
export type UsersUpdateMutationError = unknown

export const useUsersUpdate = <TError = unknown, TContext = unknown>(
    options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof usersUpdate>>, TError, { id: number; data: NonReadonly<User> }, TContext>; request?: SecondParameter<typeof customInstance> },
    queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof usersUpdate>>, TError, { id: number; data: NonReadonly<User> }, TContext> => {
    const mutationOptions = getUsersUpdateMutationOptions(options)

    return useMutation(mutationOptions, queryClient)
}

export const usersPartialUpdate = (id: number, patchedUser: NonReadonly<PatchedUser>, options?: SecondParameter<typeof customInstance>) => {
    return customInstance<User>({ url: `/api/v1/users/${id}/`, method: "PATCH", headers: { "Content-Type": "application/json" }, data: patchedUser }, options)
}

export const getUsersPartialUpdateMutationOptions = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof usersPartialUpdate>>, TError, { id: number; data: NonReadonly<PatchedUser> }, TContext>
    request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<Awaited<ReturnType<typeof usersPartialUpdate>>, TError, { id: number; data: NonReadonly<PatchedUser> }, TContext> => {
    const mutationKey = ["usersPartialUpdate"]
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined }

    const mutationFn: MutationFunction<Awaited<ReturnType<typeof usersPartialUpdate>>, { id: number; data: NonReadonly<PatchedUser> }> = (props) => {
        const { id, data } = props ?? {}

        return usersPartialUpdate(id, data, requestOptions)
    }

    return { mutationFn, ...mutationOptions }
}

export type UsersPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof usersPartialUpdate>>>
export type UsersPartialUpdateMutationBody = NonReadonly<PatchedUser>
export type UsersPartialUpdateMutationError = unknown

export const useUsersPartialUpdate = <TError = unknown, TContext = unknown>(
    options?: {
        mutation?: UseMutationOptions<Awaited<ReturnType<typeof usersPartialUpdate>>, TError, { id: number; data: NonReadonly<PatchedUser> }, TContext>
        request?: SecondParameter<typeof customInstance>
    },
    queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof usersPartialUpdate>>, TError, { id: number; data: NonReadonly<PatchedUser> }, TContext> => {
    const mutationOptions = getUsersPartialUpdateMutationOptions(options)

    return useMutation(mutationOptions, queryClient)
}

export const usersDestroy = (id: number, options?: SecondParameter<typeof customInstance>) => {
    return customInstance<void>({ url: `/api/v1/users/${id}/`, method: "DELETE" }, options)
}

export const getUsersDestroyMutationOptions = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof usersDestroy>>, TError, { id: number }, TContext>
    request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<Awaited<ReturnType<typeof usersDestroy>>, TError, { id: number }, TContext> => {
    const mutationKey = ["usersDestroy"]
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined }

    const mutationFn: MutationFunction<Awaited<ReturnType<typeof usersDestroy>>, { id: number }> = (props) => {
        const { id } = props ?? {}

        return usersDestroy(id, requestOptions)
    }

    return { mutationFn, ...mutationOptions }
}

export type UsersDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof usersDestroy>>>

export type UsersDestroyMutationError = unknown

export const useUsersDestroy = <TError = unknown, TContext = unknown>(
    options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof usersDestroy>>, TError, { id: number }, TContext>; request?: SecondParameter<typeof customInstance> },
    queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof usersDestroy>>, TError, { id: number }, TContext> => {
    const mutationOptions = getUsersDestroyMutationOptions(options)

    return useMutation(mutationOptions, queryClient)
}
