/**
 * Generated by orval v7.10.0 üç∫
 * Do not edit manually.
 * Wijckie API
 * Default API for Wijckie
 * OpenAPI spec version: 1.0.0
 */
import { useMutation, useQuery } from "@tanstack/react-query"
import type {
    DataTag,
    DefinedInitialDataOptions,
    DefinedUseQueryResult,
    MutationFunction,
    QueryClient,
    QueryFunction,
    QueryKey,
    UndefinedInitialDataOptions,
    UseMutationOptions,
    UseMutationResult,
    UseQueryOptions,
    UseQueryResult,
} from "@tanstack/react-query"

import type {
    CreateDailyTodoItem,
    CreateDailyTodoOption,
    CreateDailyTodosWidget,
    CreateInspirationItem,
    CreateInspirationOption,
    CreateInspirationWidget,
    DailyTodoItem,
    DailyTodoItemsListParams,
    DailyTodoOption,
    DailyTodoOptionsListParams,
    DailyTodosModule,
    DailyTodosModulesListParams,
    DailyTodosWidget,
    DailyTodosWidgetsListParams,
    DefaultOKResponse,
    FileUpload,
    InspirationItemsListParams,
    InspirationModule,
    InspirationModulesListParams,
    InspirationOption,
    InspirationOptionsListParams,
    InspirationWidget,
    InspirationWidgetsListParams,
    PaginatedDailyTodoItemList,
    PaginatedDailyTodoOptionList,
    PaginatedDailyTodosModuleList,
    PaginatedDailyTodosWidgetList,
    PaginatedInspirationItemList,
    PaginatedInspirationModuleList,
    PaginatedInspirationOptionList,
    PaginatedInspirationWidgetList,
    PaginatedUserList,
    PatchedDailyTodoItem,
    PatchedDailyTodoOption,
    PatchedDailyTodosModule,
    PatchedDailyTodosWidget,
    PatchedInspirationModule,
    PatchedInspirationOption,
    PatchedInspirationWidget,
    PatchedUser,
    User,
    UsersListParams,
    WidgetsBatch,
} from "../models/api"

import { customInstance } from "../../helpers/api"

// https://stackoverflow.com/questions/49579094/typescript-conditional-types-filter-out-readonly-properties-pick-only-requir/49579497#49579497
type IfEquals<X, Y, A = X, B = never> = (<T>() => T extends X ? 1 : 2) extends <T>() => T extends Y ? 1 : 2 ? A : B

type WritableKeys<T> = {
    [P in keyof T]-?: IfEquals<{ [Q in P]: T[P] }, { -readonly [Q in P]: T[P] }, P>
}[keyof T]

type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void ? I : never
type DistributeReadOnlyOverUnions<T> = T extends any ? NonReadonly<T> : never

type Writable<T> = Pick<T, WritableKeys<T>>
type NonReadonly<T> = [T] extends [UnionToIntersection<T>]
    ? {
          [P in keyof Writable<T>]: T[P] extends object ? NonReadonly<NonNullable<T[P]>> : T[P]
      }
    : DistributeReadOnlyOverUnions<T>

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1]

/**
 * Get CSRF token as a cookie.
 */
export const csrfRetrieve = (options?: SecondParameter<typeof customInstance>, signal?: AbortSignal) => {
    return customInstance<DefaultOKResponse>({ url: `/api/v1/csrf/`, method: "GET", signal }, options)
}

export const getCsrfRetrieveQueryKey = () => {
    return [`/api/v1/csrf/`] as const
}

export const getCsrfRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof csrfRetrieve>>, TError = unknown>(options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof csrfRetrieve>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
}) => {
    const { query: queryOptions, request: requestOptions } = options ?? {}

    const queryKey = queryOptions?.queryKey ?? getCsrfRetrieveQueryKey()

    const queryFn: QueryFunction<Awaited<ReturnType<typeof csrfRetrieve>>> = ({ signal }) => csrfRetrieve(requestOptions, signal)

    return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<Awaited<ReturnType<typeof csrfRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CsrfRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof csrfRetrieve>>>
export type CsrfRetrieveQueryError = unknown

export function useCsrfRetrieve<TData = Awaited<ReturnType<typeof csrfRetrieve>>, TError = unknown>(
    options: {
        query: Partial<UseQueryOptions<Awaited<ReturnType<typeof csrfRetrieve>>, TError, TData>> &
            Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof csrfRetrieve>>, TError, Awaited<ReturnType<typeof csrfRetrieve>>>, "initialData">
        request?: SecondParameter<typeof customInstance>
    },
    queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCsrfRetrieve<TData = Awaited<ReturnType<typeof csrfRetrieve>>, TError = unknown>(
    options?: {
        query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof csrfRetrieve>>, TError, TData>> &
            Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof csrfRetrieve>>, TError, Awaited<ReturnType<typeof csrfRetrieve>>>, "initialData">
        request?: SecondParameter<typeof customInstance>
    },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCsrfRetrieve<TData = Awaited<ReturnType<typeof csrfRetrieve>>, TError = unknown>(
    options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof csrfRetrieve>>, TError, TData>>; request?: SecondParameter<typeof customInstance> },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useCsrfRetrieve<TData = Awaited<ReturnType<typeof csrfRetrieve>>, TError = unknown>(
    options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof csrfRetrieve>>, TError, TData>>; request?: SecondParameter<typeof customInstance> },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
    const queryOptions = getCsrfRetrieveQueryOptions(options)

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

    query.queryKey = queryOptions.queryKey

    return query
}

export const dailyTodoItemsList = (params?: DailyTodoItemsListParams, options?: SecondParameter<typeof customInstance>, signal?: AbortSignal) => {
    return customInstance<PaginatedDailyTodoItemList>({ url: `/api/v1/daily-todo-items/`, method: "GET", params, signal }, options)
}

export const getDailyTodoItemsListQueryKey = (params?: DailyTodoItemsListParams) => {
    return [`/api/v1/daily-todo-items/`, ...(params ? [params] : [])] as const
}

export const getDailyTodoItemsListQueryOptions = <TData = Awaited<ReturnType<typeof dailyTodoItemsList>>, TError = unknown>(
    params?: DailyTodoItemsListParams,
    options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof dailyTodoItemsList>>, TError, TData>>; request?: SecondParameter<typeof customInstance> }
) => {
    const { query: queryOptions, request: requestOptions } = options ?? {}

    const queryKey = queryOptions?.queryKey ?? getDailyTodoItemsListQueryKey(params)

    const queryFn: QueryFunction<Awaited<ReturnType<typeof dailyTodoItemsList>>> = ({ signal }) => dailyTodoItemsList(params, requestOptions, signal)

    return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<Awaited<ReturnType<typeof dailyTodoItemsList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type DailyTodoItemsListQueryResult = NonNullable<Awaited<ReturnType<typeof dailyTodoItemsList>>>
export type DailyTodoItemsListQueryError = unknown

export function useDailyTodoItemsList<TData = Awaited<ReturnType<typeof dailyTodoItemsList>>, TError = unknown>(
    params: undefined | DailyTodoItemsListParams,
    options: {
        query: Partial<UseQueryOptions<Awaited<ReturnType<typeof dailyTodoItemsList>>, TError, TData>> &
            Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof dailyTodoItemsList>>, TError, Awaited<ReturnType<typeof dailyTodoItemsList>>>, "initialData">
        request?: SecondParameter<typeof customInstance>
    },
    queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useDailyTodoItemsList<TData = Awaited<ReturnType<typeof dailyTodoItemsList>>, TError = unknown>(
    params?: DailyTodoItemsListParams,
    options?: {
        query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof dailyTodoItemsList>>, TError, TData>> &
            Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof dailyTodoItemsList>>, TError, Awaited<ReturnType<typeof dailyTodoItemsList>>>, "initialData">
        request?: SecondParameter<typeof customInstance>
    },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useDailyTodoItemsList<TData = Awaited<ReturnType<typeof dailyTodoItemsList>>, TError = unknown>(
    params?: DailyTodoItemsListParams,
    options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof dailyTodoItemsList>>, TError, TData>>; request?: SecondParameter<typeof customInstance> },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useDailyTodoItemsList<TData = Awaited<ReturnType<typeof dailyTodoItemsList>>, TError = unknown>(
    params?: DailyTodoItemsListParams,
    options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof dailyTodoItemsList>>, TError, TData>>; request?: SecondParameter<typeof customInstance> },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
    const queryOptions = getDailyTodoItemsListQueryOptions(params, options)

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

    query.queryKey = queryOptions.queryKey

    return query
}

export const dailyTodoItemsCreate = (createDailyTodoItem: NonReadonly<CreateDailyTodoItem>, options?: SecondParameter<typeof customInstance>, signal?: AbortSignal) => {
    return customInstance<CreateDailyTodoItem>({ url: `/api/v1/daily-todo-items/`, method: "POST", headers: { "Content-Type": "application/json" }, data: createDailyTodoItem, signal }, options)
}

export const getDailyTodoItemsCreateMutationOptions = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof dailyTodoItemsCreate>>, TError, { data: NonReadonly<CreateDailyTodoItem> }, TContext>
    request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<Awaited<ReturnType<typeof dailyTodoItemsCreate>>, TError, { data: NonReadonly<CreateDailyTodoItem> }, TContext> => {
    const mutationKey = ["dailyTodoItemsCreate"]
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined }

    const mutationFn: MutationFunction<Awaited<ReturnType<typeof dailyTodoItemsCreate>>, { data: NonReadonly<CreateDailyTodoItem> }> = (props) => {
        const { data } = props ?? {}

        return dailyTodoItemsCreate(data, requestOptions)
    }

    return { mutationFn, ...mutationOptions }
}

export type DailyTodoItemsCreateMutationResult = NonNullable<Awaited<ReturnType<typeof dailyTodoItemsCreate>>>
export type DailyTodoItemsCreateMutationBody = NonReadonly<CreateDailyTodoItem>
export type DailyTodoItemsCreateMutationError = unknown

export const useDailyTodoItemsCreate = <TError = unknown, TContext = unknown>(
    options?: {
        mutation?: UseMutationOptions<Awaited<ReturnType<typeof dailyTodoItemsCreate>>, TError, { data: NonReadonly<CreateDailyTodoItem> }, TContext>
        request?: SecondParameter<typeof customInstance>
    },
    queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof dailyTodoItemsCreate>>, TError, { data: NonReadonly<CreateDailyTodoItem> }, TContext> => {
    const mutationOptions = getDailyTodoItemsCreateMutationOptions(options)

    return useMutation(mutationOptions, queryClient)
}

export const dailyTodoItemsUpdate = (id: number, dailyTodoItem: NonReadonly<DailyTodoItem>, options?: SecondParameter<typeof customInstance>) => {
    return customInstance<DailyTodoItem>({ url: `/api/v1/daily-todo-items/${id}/`, method: "PUT", headers: { "Content-Type": "application/json" }, data: dailyTodoItem }, options)
}

export const getDailyTodoItemsUpdateMutationOptions = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof dailyTodoItemsUpdate>>, TError, { id: number; data: NonReadonly<DailyTodoItem> }, TContext>
    request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<Awaited<ReturnType<typeof dailyTodoItemsUpdate>>, TError, { id: number; data: NonReadonly<DailyTodoItem> }, TContext> => {
    const mutationKey = ["dailyTodoItemsUpdate"]
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined }

    const mutationFn: MutationFunction<Awaited<ReturnType<typeof dailyTodoItemsUpdate>>, { id: number; data: NonReadonly<DailyTodoItem> }> = (props) => {
        const { id, data } = props ?? {}

        return dailyTodoItemsUpdate(id, data, requestOptions)
    }

    return { mutationFn, ...mutationOptions }
}

export type DailyTodoItemsUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof dailyTodoItemsUpdate>>>
export type DailyTodoItemsUpdateMutationBody = NonReadonly<DailyTodoItem>
export type DailyTodoItemsUpdateMutationError = unknown

export const useDailyTodoItemsUpdate = <TError = unknown, TContext = unknown>(
    options?: {
        mutation?: UseMutationOptions<Awaited<ReturnType<typeof dailyTodoItemsUpdate>>, TError, { id: number; data: NonReadonly<DailyTodoItem> }, TContext>
        request?: SecondParameter<typeof customInstance>
    },
    queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof dailyTodoItemsUpdate>>, TError, { id: number; data: NonReadonly<DailyTodoItem> }, TContext> => {
    const mutationOptions = getDailyTodoItemsUpdateMutationOptions(options)

    return useMutation(mutationOptions, queryClient)
}

export const dailyTodoItemsPartialUpdate = (id: number, patchedDailyTodoItem: NonReadonly<PatchedDailyTodoItem>, options?: SecondParameter<typeof customInstance>) => {
    return customInstance<DailyTodoItem>({ url: `/api/v1/daily-todo-items/${id}/`, method: "PATCH", headers: { "Content-Type": "application/json" }, data: patchedDailyTodoItem }, options)
}

export const getDailyTodoItemsPartialUpdateMutationOptions = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof dailyTodoItemsPartialUpdate>>, TError, { id: number; data: NonReadonly<PatchedDailyTodoItem> }, TContext>
    request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<Awaited<ReturnType<typeof dailyTodoItemsPartialUpdate>>, TError, { id: number; data: NonReadonly<PatchedDailyTodoItem> }, TContext> => {
    const mutationKey = ["dailyTodoItemsPartialUpdate"]
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined }

    const mutationFn: MutationFunction<Awaited<ReturnType<typeof dailyTodoItemsPartialUpdate>>, { id: number; data: NonReadonly<PatchedDailyTodoItem> }> = (props) => {
        const { id, data } = props ?? {}

        return dailyTodoItemsPartialUpdate(id, data, requestOptions)
    }

    return { mutationFn, ...mutationOptions }
}

export type DailyTodoItemsPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof dailyTodoItemsPartialUpdate>>>
export type DailyTodoItemsPartialUpdateMutationBody = NonReadonly<PatchedDailyTodoItem>
export type DailyTodoItemsPartialUpdateMutationError = unknown

export const useDailyTodoItemsPartialUpdate = <TError = unknown, TContext = unknown>(
    options?: {
        mutation?: UseMutationOptions<Awaited<ReturnType<typeof dailyTodoItemsPartialUpdate>>, TError, { id: number; data: NonReadonly<PatchedDailyTodoItem> }, TContext>
        request?: SecondParameter<typeof customInstance>
    },
    queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof dailyTodoItemsPartialUpdate>>, TError, { id: number; data: NonReadonly<PatchedDailyTodoItem> }, TContext> => {
    const mutationOptions = getDailyTodoItemsPartialUpdateMutationOptions(options)

    return useMutation(mutationOptions, queryClient)
}

export const dailyTodoOptionsList = (params?: DailyTodoOptionsListParams, options?: SecondParameter<typeof customInstance>, signal?: AbortSignal) => {
    return customInstance<PaginatedDailyTodoOptionList>({ url: `/api/v1/daily-todo-options/`, method: "GET", params, signal }, options)
}

export const getDailyTodoOptionsListQueryKey = (params?: DailyTodoOptionsListParams) => {
    return [`/api/v1/daily-todo-options/`, ...(params ? [params] : [])] as const
}

export const getDailyTodoOptionsListQueryOptions = <TData = Awaited<ReturnType<typeof dailyTodoOptionsList>>, TError = unknown>(
    params?: DailyTodoOptionsListParams,
    options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof dailyTodoOptionsList>>, TError, TData>>; request?: SecondParameter<typeof customInstance> }
) => {
    const { query: queryOptions, request: requestOptions } = options ?? {}

    const queryKey = queryOptions?.queryKey ?? getDailyTodoOptionsListQueryKey(params)

    const queryFn: QueryFunction<Awaited<ReturnType<typeof dailyTodoOptionsList>>> = ({ signal }) => dailyTodoOptionsList(params, requestOptions, signal)

    return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<Awaited<ReturnType<typeof dailyTodoOptionsList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type DailyTodoOptionsListQueryResult = NonNullable<Awaited<ReturnType<typeof dailyTodoOptionsList>>>
export type DailyTodoOptionsListQueryError = unknown

export function useDailyTodoOptionsList<TData = Awaited<ReturnType<typeof dailyTodoOptionsList>>, TError = unknown>(
    params: undefined | DailyTodoOptionsListParams,
    options: {
        query: Partial<UseQueryOptions<Awaited<ReturnType<typeof dailyTodoOptionsList>>, TError, TData>> &
            Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof dailyTodoOptionsList>>, TError, Awaited<ReturnType<typeof dailyTodoOptionsList>>>, "initialData">
        request?: SecondParameter<typeof customInstance>
    },
    queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useDailyTodoOptionsList<TData = Awaited<ReturnType<typeof dailyTodoOptionsList>>, TError = unknown>(
    params?: DailyTodoOptionsListParams,
    options?: {
        query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof dailyTodoOptionsList>>, TError, TData>> &
            Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof dailyTodoOptionsList>>, TError, Awaited<ReturnType<typeof dailyTodoOptionsList>>>, "initialData">
        request?: SecondParameter<typeof customInstance>
    },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useDailyTodoOptionsList<TData = Awaited<ReturnType<typeof dailyTodoOptionsList>>, TError = unknown>(
    params?: DailyTodoOptionsListParams,
    options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof dailyTodoOptionsList>>, TError, TData>>; request?: SecondParameter<typeof customInstance> },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useDailyTodoOptionsList<TData = Awaited<ReturnType<typeof dailyTodoOptionsList>>, TError = unknown>(
    params?: DailyTodoOptionsListParams,
    options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof dailyTodoOptionsList>>, TError, TData>>; request?: SecondParameter<typeof customInstance> },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
    const queryOptions = getDailyTodoOptionsListQueryOptions(params, options)

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

    query.queryKey = queryOptions.queryKey

    return query
}

export const dailyTodoOptionsCreate = (createDailyTodoOption: NonReadonly<CreateDailyTodoOption>, options?: SecondParameter<typeof customInstance>, signal?: AbortSignal) => {
    return customInstance<CreateDailyTodoOption>({ url: `/api/v1/daily-todo-options/`, method: "POST", headers: { "Content-Type": "application/json" }, data: createDailyTodoOption, signal }, options)
}

export const getDailyTodoOptionsCreateMutationOptions = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof dailyTodoOptionsCreate>>, TError, { data: NonReadonly<CreateDailyTodoOption> }, TContext>
    request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<Awaited<ReturnType<typeof dailyTodoOptionsCreate>>, TError, { data: NonReadonly<CreateDailyTodoOption> }, TContext> => {
    const mutationKey = ["dailyTodoOptionsCreate"]
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined }

    const mutationFn: MutationFunction<Awaited<ReturnType<typeof dailyTodoOptionsCreate>>, { data: NonReadonly<CreateDailyTodoOption> }> = (props) => {
        const { data } = props ?? {}

        return dailyTodoOptionsCreate(data, requestOptions)
    }

    return { mutationFn, ...mutationOptions }
}

export type DailyTodoOptionsCreateMutationResult = NonNullable<Awaited<ReturnType<typeof dailyTodoOptionsCreate>>>
export type DailyTodoOptionsCreateMutationBody = NonReadonly<CreateDailyTodoOption>
export type DailyTodoOptionsCreateMutationError = unknown

export const useDailyTodoOptionsCreate = <TError = unknown, TContext = unknown>(
    options?: {
        mutation?: UseMutationOptions<Awaited<ReturnType<typeof dailyTodoOptionsCreate>>, TError, { data: NonReadonly<CreateDailyTodoOption> }, TContext>
        request?: SecondParameter<typeof customInstance>
    },
    queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof dailyTodoOptionsCreate>>, TError, { data: NonReadonly<CreateDailyTodoOption> }, TContext> => {
    const mutationOptions = getDailyTodoOptionsCreateMutationOptions(options)

    return useMutation(mutationOptions, queryClient)
}

export const dailyTodoOptionsRetrieve = (id: number, options?: SecondParameter<typeof customInstance>, signal?: AbortSignal) => {
    return customInstance<DailyTodoOption>({ url: `/api/v1/daily-todo-options/${id}/`, method: "GET", signal }, options)
}

export const getDailyTodoOptionsRetrieveQueryKey = (id: number) => {
    return [`/api/v1/daily-todo-options/${id}/`] as const
}

export const getDailyTodoOptionsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof dailyTodoOptionsRetrieve>>, TError = unknown>(
    id: number,
    options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof dailyTodoOptionsRetrieve>>, TError, TData>>; request?: SecondParameter<typeof customInstance> }
) => {
    const { query: queryOptions, request: requestOptions } = options ?? {}

    const queryKey = queryOptions?.queryKey ?? getDailyTodoOptionsRetrieveQueryKey(id)

    const queryFn: QueryFunction<Awaited<ReturnType<typeof dailyTodoOptionsRetrieve>>> = ({ signal }) => dailyTodoOptionsRetrieve(id, requestOptions, signal)

    return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<Awaited<ReturnType<typeof dailyTodoOptionsRetrieve>>, TError, TData> & {
        queryKey: DataTag<QueryKey, TData, TError>
    }
}

export type DailyTodoOptionsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof dailyTodoOptionsRetrieve>>>
export type DailyTodoOptionsRetrieveQueryError = unknown

export function useDailyTodoOptionsRetrieve<TData = Awaited<ReturnType<typeof dailyTodoOptionsRetrieve>>, TError = unknown>(
    id: number,
    options: {
        query: Partial<UseQueryOptions<Awaited<ReturnType<typeof dailyTodoOptionsRetrieve>>, TError, TData>> &
            Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof dailyTodoOptionsRetrieve>>, TError, Awaited<ReturnType<typeof dailyTodoOptionsRetrieve>>>, "initialData">
        request?: SecondParameter<typeof customInstance>
    },
    queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useDailyTodoOptionsRetrieve<TData = Awaited<ReturnType<typeof dailyTodoOptionsRetrieve>>, TError = unknown>(
    id: number,
    options?: {
        query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof dailyTodoOptionsRetrieve>>, TError, TData>> &
            Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof dailyTodoOptionsRetrieve>>, TError, Awaited<ReturnType<typeof dailyTodoOptionsRetrieve>>>, "initialData">
        request?: SecondParameter<typeof customInstance>
    },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useDailyTodoOptionsRetrieve<TData = Awaited<ReturnType<typeof dailyTodoOptionsRetrieve>>, TError = unknown>(
    id: number,
    options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof dailyTodoOptionsRetrieve>>, TError, TData>>; request?: SecondParameter<typeof customInstance> },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useDailyTodoOptionsRetrieve<TData = Awaited<ReturnType<typeof dailyTodoOptionsRetrieve>>, TError = unknown>(
    id: number,
    options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof dailyTodoOptionsRetrieve>>, TError, TData>>; request?: SecondParameter<typeof customInstance> },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
    const queryOptions = getDailyTodoOptionsRetrieveQueryOptions(id, options)

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

    query.queryKey = queryOptions.queryKey

    return query
}

export const dailyTodoOptionsUpdate = (id: number, dailyTodoOption: NonReadonly<DailyTodoOption>, options?: SecondParameter<typeof customInstance>) => {
    return customInstance<DailyTodoOption>({ url: `/api/v1/daily-todo-options/${id}/`, method: "PUT", headers: { "Content-Type": "application/json" }, data: dailyTodoOption }, options)
}

export const getDailyTodoOptionsUpdateMutationOptions = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof dailyTodoOptionsUpdate>>, TError, { id: number; data: NonReadonly<DailyTodoOption> }, TContext>
    request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<Awaited<ReturnType<typeof dailyTodoOptionsUpdate>>, TError, { id: number; data: NonReadonly<DailyTodoOption> }, TContext> => {
    const mutationKey = ["dailyTodoOptionsUpdate"]
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined }

    const mutationFn: MutationFunction<Awaited<ReturnType<typeof dailyTodoOptionsUpdate>>, { id: number; data: NonReadonly<DailyTodoOption> }> = (props) => {
        const { id, data } = props ?? {}

        return dailyTodoOptionsUpdate(id, data, requestOptions)
    }

    return { mutationFn, ...mutationOptions }
}

export type DailyTodoOptionsUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof dailyTodoOptionsUpdate>>>
export type DailyTodoOptionsUpdateMutationBody = NonReadonly<DailyTodoOption>
export type DailyTodoOptionsUpdateMutationError = unknown

export const useDailyTodoOptionsUpdate = <TError = unknown, TContext = unknown>(
    options?: {
        mutation?: UseMutationOptions<Awaited<ReturnType<typeof dailyTodoOptionsUpdate>>, TError, { id: number; data: NonReadonly<DailyTodoOption> }, TContext>
        request?: SecondParameter<typeof customInstance>
    },
    queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof dailyTodoOptionsUpdate>>, TError, { id: number; data: NonReadonly<DailyTodoOption> }, TContext> => {
    const mutationOptions = getDailyTodoOptionsUpdateMutationOptions(options)

    return useMutation(mutationOptions, queryClient)
}

export const dailyTodoOptionsPartialUpdate = (id: number, patchedDailyTodoOption: NonReadonly<PatchedDailyTodoOption>, options?: SecondParameter<typeof customInstance>) => {
    return customInstance<DailyTodoOption>({ url: `/api/v1/daily-todo-options/${id}/`, method: "PATCH", headers: { "Content-Type": "application/json" }, data: patchedDailyTodoOption }, options)
}

export const getDailyTodoOptionsPartialUpdateMutationOptions = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof dailyTodoOptionsPartialUpdate>>, TError, { id: number; data: NonReadonly<PatchedDailyTodoOption> }, TContext>
    request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<Awaited<ReturnType<typeof dailyTodoOptionsPartialUpdate>>, TError, { id: number; data: NonReadonly<PatchedDailyTodoOption> }, TContext> => {
    const mutationKey = ["dailyTodoOptionsPartialUpdate"]
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined }

    const mutationFn: MutationFunction<Awaited<ReturnType<typeof dailyTodoOptionsPartialUpdate>>, { id: number; data: NonReadonly<PatchedDailyTodoOption> }> = (props) => {
        const { id, data } = props ?? {}

        return dailyTodoOptionsPartialUpdate(id, data, requestOptions)
    }

    return { mutationFn, ...mutationOptions }
}

export type DailyTodoOptionsPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof dailyTodoOptionsPartialUpdate>>>
export type DailyTodoOptionsPartialUpdateMutationBody = NonReadonly<PatchedDailyTodoOption>
export type DailyTodoOptionsPartialUpdateMutationError = unknown

export const useDailyTodoOptionsPartialUpdate = <TError = unknown, TContext = unknown>(
    options?: {
        mutation?: UseMutationOptions<Awaited<ReturnType<typeof dailyTodoOptionsPartialUpdate>>, TError, { id: number; data: NonReadonly<PatchedDailyTodoOption> }, TContext>
        request?: SecondParameter<typeof customInstance>
    },
    queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof dailyTodoOptionsPartialUpdate>>, TError, { id: number; data: NonReadonly<PatchedDailyTodoOption> }, TContext> => {
    const mutationOptions = getDailyTodoOptionsPartialUpdateMutationOptions(options)

    return useMutation(mutationOptions, queryClient)
}

export const dailyTodoOptionsDestroy = (id: number, options?: SecondParameter<typeof customInstance>) => {
    return customInstance<void>({ url: `/api/v1/daily-todo-options/${id}/`, method: "DELETE" }, options)
}

export const getDailyTodoOptionsDestroyMutationOptions = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof dailyTodoOptionsDestroy>>, TError, { id: number }, TContext>
    request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<Awaited<ReturnType<typeof dailyTodoOptionsDestroy>>, TError, { id: number }, TContext> => {
    const mutationKey = ["dailyTodoOptionsDestroy"]
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined }

    const mutationFn: MutationFunction<Awaited<ReturnType<typeof dailyTodoOptionsDestroy>>, { id: number }> = (props) => {
        const { id } = props ?? {}

        return dailyTodoOptionsDestroy(id, requestOptions)
    }

    return { mutationFn, ...mutationOptions }
}

export type DailyTodoOptionsDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof dailyTodoOptionsDestroy>>>

export type DailyTodoOptionsDestroyMutationError = unknown

export const useDailyTodoOptionsDestroy = <TError = unknown, TContext = unknown>(
    options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof dailyTodoOptionsDestroy>>, TError, { id: number }, TContext>; request?: SecondParameter<typeof customInstance> },
    queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof dailyTodoOptionsDestroy>>, TError, { id: number }, TContext> => {
    const mutationOptions = getDailyTodoOptionsDestroyMutationOptions(options)

    return useMutation(mutationOptions, queryClient)
}

export const dailyTodosModulesList = (params?: DailyTodosModulesListParams, options?: SecondParameter<typeof customInstance>, signal?: AbortSignal) => {
    return customInstance<PaginatedDailyTodosModuleList>({ url: `/api/v1/daily-todos-modules/`, method: "GET", params, signal }, options)
}

export const getDailyTodosModulesListQueryKey = (params?: DailyTodosModulesListParams) => {
    return [`/api/v1/daily-todos-modules/`, ...(params ? [params] : [])] as const
}

export const getDailyTodosModulesListQueryOptions = <TData = Awaited<ReturnType<typeof dailyTodosModulesList>>, TError = unknown>(
    params?: DailyTodosModulesListParams,
    options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof dailyTodosModulesList>>, TError, TData>>; request?: SecondParameter<typeof customInstance> }
) => {
    const { query: queryOptions, request: requestOptions } = options ?? {}

    const queryKey = queryOptions?.queryKey ?? getDailyTodosModulesListQueryKey(params)

    const queryFn: QueryFunction<Awaited<ReturnType<typeof dailyTodosModulesList>>> = ({ signal }) => dailyTodosModulesList(params, requestOptions, signal)

    return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<Awaited<ReturnType<typeof dailyTodosModulesList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type DailyTodosModulesListQueryResult = NonNullable<Awaited<ReturnType<typeof dailyTodosModulesList>>>
export type DailyTodosModulesListQueryError = unknown

export function useDailyTodosModulesList<TData = Awaited<ReturnType<typeof dailyTodosModulesList>>, TError = unknown>(
    params: undefined | DailyTodosModulesListParams,
    options: {
        query: Partial<UseQueryOptions<Awaited<ReturnType<typeof dailyTodosModulesList>>, TError, TData>> &
            Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof dailyTodosModulesList>>, TError, Awaited<ReturnType<typeof dailyTodosModulesList>>>, "initialData">
        request?: SecondParameter<typeof customInstance>
    },
    queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useDailyTodosModulesList<TData = Awaited<ReturnType<typeof dailyTodosModulesList>>, TError = unknown>(
    params?: DailyTodosModulesListParams,
    options?: {
        query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof dailyTodosModulesList>>, TError, TData>> &
            Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof dailyTodosModulesList>>, TError, Awaited<ReturnType<typeof dailyTodosModulesList>>>, "initialData">
        request?: SecondParameter<typeof customInstance>
    },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useDailyTodosModulesList<TData = Awaited<ReturnType<typeof dailyTodosModulesList>>, TError = unknown>(
    params?: DailyTodosModulesListParams,
    options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof dailyTodosModulesList>>, TError, TData>>; request?: SecondParameter<typeof customInstance> },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useDailyTodosModulesList<TData = Awaited<ReturnType<typeof dailyTodosModulesList>>, TError = unknown>(
    params?: DailyTodosModulesListParams,
    options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof dailyTodosModulesList>>, TError, TData>>; request?: SecondParameter<typeof customInstance> },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
    const queryOptions = getDailyTodosModulesListQueryOptions(params, options)

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

    query.queryKey = queryOptions.queryKey

    return query
}

export const dailyTodosModulesCreate = (dailyTodosModule: NonReadonly<DailyTodosModule>, options?: SecondParameter<typeof customInstance>, signal?: AbortSignal) => {
    return customInstance<DailyTodosModule>({ url: `/api/v1/daily-todos-modules/`, method: "POST", headers: { "Content-Type": "application/json" }, data: dailyTodosModule, signal }, options)
}

export const getDailyTodosModulesCreateMutationOptions = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof dailyTodosModulesCreate>>, TError, { data: NonReadonly<DailyTodosModule> }, TContext>
    request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<Awaited<ReturnType<typeof dailyTodosModulesCreate>>, TError, { data: NonReadonly<DailyTodosModule> }, TContext> => {
    const mutationKey = ["dailyTodosModulesCreate"]
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined }

    const mutationFn: MutationFunction<Awaited<ReturnType<typeof dailyTodosModulesCreate>>, { data: NonReadonly<DailyTodosModule> }> = (props) => {
        const { data } = props ?? {}

        return dailyTodosModulesCreate(data, requestOptions)
    }

    return { mutationFn, ...mutationOptions }
}

export type DailyTodosModulesCreateMutationResult = NonNullable<Awaited<ReturnType<typeof dailyTodosModulesCreate>>>
export type DailyTodosModulesCreateMutationBody = NonReadonly<DailyTodosModule>
export type DailyTodosModulesCreateMutationError = unknown

export const useDailyTodosModulesCreate = <TError = unknown, TContext = unknown>(
    options?: {
        mutation?: UseMutationOptions<Awaited<ReturnType<typeof dailyTodosModulesCreate>>, TError, { data: NonReadonly<DailyTodosModule> }, TContext>
        request?: SecondParameter<typeof customInstance>
    },
    queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof dailyTodosModulesCreate>>, TError, { data: NonReadonly<DailyTodosModule> }, TContext> => {
    const mutationOptions = getDailyTodosModulesCreateMutationOptions(options)

    return useMutation(mutationOptions, queryClient)
}

export const dailyTodosModulesRetrieve = (id: number, options?: SecondParameter<typeof customInstance>, signal?: AbortSignal) => {
    return customInstance<DailyTodosModule>({ url: `/api/v1/daily-todos-modules/${id}/`, method: "GET", signal }, options)
}

export const getDailyTodosModulesRetrieveQueryKey = (id: number) => {
    return [`/api/v1/daily-todos-modules/${id}/`] as const
}

export const getDailyTodosModulesRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof dailyTodosModulesRetrieve>>, TError = unknown>(
    id: number,
    options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof dailyTodosModulesRetrieve>>, TError, TData>>; request?: SecondParameter<typeof customInstance> }
) => {
    const { query: queryOptions, request: requestOptions } = options ?? {}

    const queryKey = queryOptions?.queryKey ?? getDailyTodosModulesRetrieveQueryKey(id)

    const queryFn: QueryFunction<Awaited<ReturnType<typeof dailyTodosModulesRetrieve>>> = ({ signal }) => dailyTodosModulesRetrieve(id, requestOptions, signal)

    return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<Awaited<ReturnType<typeof dailyTodosModulesRetrieve>>, TError, TData> & {
        queryKey: DataTag<QueryKey, TData, TError>
    }
}

export type DailyTodosModulesRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof dailyTodosModulesRetrieve>>>
export type DailyTodosModulesRetrieveQueryError = unknown

export function useDailyTodosModulesRetrieve<TData = Awaited<ReturnType<typeof dailyTodosModulesRetrieve>>, TError = unknown>(
    id: number,
    options: {
        query: Partial<UseQueryOptions<Awaited<ReturnType<typeof dailyTodosModulesRetrieve>>, TError, TData>> &
            Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof dailyTodosModulesRetrieve>>, TError, Awaited<ReturnType<typeof dailyTodosModulesRetrieve>>>, "initialData">
        request?: SecondParameter<typeof customInstance>
    },
    queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useDailyTodosModulesRetrieve<TData = Awaited<ReturnType<typeof dailyTodosModulesRetrieve>>, TError = unknown>(
    id: number,
    options?: {
        query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof dailyTodosModulesRetrieve>>, TError, TData>> &
            Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof dailyTodosModulesRetrieve>>, TError, Awaited<ReturnType<typeof dailyTodosModulesRetrieve>>>, "initialData">
        request?: SecondParameter<typeof customInstance>
    },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useDailyTodosModulesRetrieve<TData = Awaited<ReturnType<typeof dailyTodosModulesRetrieve>>, TError = unknown>(
    id: number,
    options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof dailyTodosModulesRetrieve>>, TError, TData>>; request?: SecondParameter<typeof customInstance> },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useDailyTodosModulesRetrieve<TData = Awaited<ReturnType<typeof dailyTodosModulesRetrieve>>, TError = unknown>(
    id: number,
    options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof dailyTodosModulesRetrieve>>, TError, TData>>; request?: SecondParameter<typeof customInstance> },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
    const queryOptions = getDailyTodosModulesRetrieveQueryOptions(id, options)

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

    query.queryKey = queryOptions.queryKey

    return query
}

export const dailyTodosModulesUpdate = (id: number, dailyTodosModule: NonReadonly<DailyTodosModule>, options?: SecondParameter<typeof customInstance>) => {
    return customInstance<DailyTodosModule>({ url: `/api/v1/daily-todos-modules/${id}/`, method: "PUT", headers: { "Content-Type": "application/json" }, data: dailyTodosModule }, options)
}

export const getDailyTodosModulesUpdateMutationOptions = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof dailyTodosModulesUpdate>>, TError, { id: number; data: NonReadonly<DailyTodosModule> }, TContext>
    request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<Awaited<ReturnType<typeof dailyTodosModulesUpdate>>, TError, { id: number; data: NonReadonly<DailyTodosModule> }, TContext> => {
    const mutationKey = ["dailyTodosModulesUpdate"]
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined }

    const mutationFn: MutationFunction<Awaited<ReturnType<typeof dailyTodosModulesUpdate>>, { id: number; data: NonReadonly<DailyTodosModule> }> = (props) => {
        const { id, data } = props ?? {}

        return dailyTodosModulesUpdate(id, data, requestOptions)
    }

    return { mutationFn, ...mutationOptions }
}

export type DailyTodosModulesUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof dailyTodosModulesUpdate>>>
export type DailyTodosModulesUpdateMutationBody = NonReadonly<DailyTodosModule>
export type DailyTodosModulesUpdateMutationError = unknown

export const useDailyTodosModulesUpdate = <TError = unknown, TContext = unknown>(
    options?: {
        mutation?: UseMutationOptions<Awaited<ReturnType<typeof dailyTodosModulesUpdate>>, TError, { id: number; data: NonReadonly<DailyTodosModule> }, TContext>
        request?: SecondParameter<typeof customInstance>
    },
    queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof dailyTodosModulesUpdate>>, TError, { id: number; data: NonReadonly<DailyTodosModule> }, TContext> => {
    const mutationOptions = getDailyTodosModulesUpdateMutationOptions(options)

    return useMutation(mutationOptions, queryClient)
}

export const dailyTodosModulesPartialUpdate = (id: number, patchedDailyTodosModule: NonReadonly<PatchedDailyTodosModule>, options?: SecondParameter<typeof customInstance>) => {
    return customInstance<DailyTodosModule>({ url: `/api/v1/daily-todos-modules/${id}/`, method: "PATCH", headers: { "Content-Type": "application/json" }, data: patchedDailyTodosModule }, options)
}

export const getDailyTodosModulesPartialUpdateMutationOptions = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof dailyTodosModulesPartialUpdate>>, TError, { id: number; data: NonReadonly<PatchedDailyTodosModule> }, TContext>
    request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<Awaited<ReturnType<typeof dailyTodosModulesPartialUpdate>>, TError, { id: number; data: NonReadonly<PatchedDailyTodosModule> }, TContext> => {
    const mutationKey = ["dailyTodosModulesPartialUpdate"]
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined }

    const mutationFn: MutationFunction<Awaited<ReturnType<typeof dailyTodosModulesPartialUpdate>>, { id: number; data: NonReadonly<PatchedDailyTodosModule> }> = (props) => {
        const { id, data } = props ?? {}

        return dailyTodosModulesPartialUpdate(id, data, requestOptions)
    }

    return { mutationFn, ...mutationOptions }
}

export type DailyTodosModulesPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof dailyTodosModulesPartialUpdate>>>
export type DailyTodosModulesPartialUpdateMutationBody = NonReadonly<PatchedDailyTodosModule>
export type DailyTodosModulesPartialUpdateMutationError = unknown

export const useDailyTodosModulesPartialUpdate = <TError = unknown, TContext = unknown>(
    options?: {
        mutation?: UseMutationOptions<Awaited<ReturnType<typeof dailyTodosModulesPartialUpdate>>, TError, { id: number; data: NonReadonly<PatchedDailyTodosModule> }, TContext>
        request?: SecondParameter<typeof customInstance>
    },
    queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof dailyTodosModulesPartialUpdate>>, TError, { id: number; data: NonReadonly<PatchedDailyTodosModule> }, TContext> => {
    const mutationOptions = getDailyTodosModulesPartialUpdateMutationOptions(options)

    return useMutation(mutationOptions, queryClient)
}

export const dailyTodosModulesDestroy = (id: number, options?: SecondParameter<typeof customInstance>) => {
    return customInstance<void>({ url: `/api/v1/daily-todos-modules/${id}/`, method: "DELETE" }, options)
}

export const getDailyTodosModulesDestroyMutationOptions = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof dailyTodosModulesDestroy>>, TError, { id: number }, TContext>
    request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<Awaited<ReturnType<typeof dailyTodosModulesDestroy>>, TError, { id: number }, TContext> => {
    const mutationKey = ["dailyTodosModulesDestroy"]
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined }

    const mutationFn: MutationFunction<Awaited<ReturnType<typeof dailyTodosModulesDestroy>>, { id: number }> = (props) => {
        const { id } = props ?? {}

        return dailyTodosModulesDestroy(id, requestOptions)
    }

    return { mutationFn, ...mutationOptions }
}

export type DailyTodosModulesDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof dailyTodosModulesDestroy>>>

export type DailyTodosModulesDestroyMutationError = unknown

export const useDailyTodosModulesDestroy = <TError = unknown, TContext = unknown>(
    options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof dailyTodosModulesDestroy>>, TError, { id: number }, TContext>; request?: SecondParameter<typeof customInstance> },
    queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof dailyTodosModulesDestroy>>, TError, { id: number }, TContext> => {
    const mutationOptions = getDailyTodosModulesDestroyMutationOptions(options)

    return useMutation(mutationOptions, queryClient)
}

export const dailyTodosWidgetsList = (params?: DailyTodosWidgetsListParams, options?: SecondParameter<typeof customInstance>, signal?: AbortSignal) => {
    return customInstance<PaginatedDailyTodosWidgetList>({ url: `/api/v1/daily-todos-widgets/`, method: "GET", params, signal }, options)
}

export const getDailyTodosWidgetsListQueryKey = (params?: DailyTodosWidgetsListParams) => {
    return [`/api/v1/daily-todos-widgets/`, ...(params ? [params] : [])] as const
}

export const getDailyTodosWidgetsListQueryOptions = <TData = Awaited<ReturnType<typeof dailyTodosWidgetsList>>, TError = unknown>(
    params?: DailyTodosWidgetsListParams,
    options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof dailyTodosWidgetsList>>, TError, TData>>; request?: SecondParameter<typeof customInstance> }
) => {
    const { query: queryOptions, request: requestOptions } = options ?? {}

    const queryKey = queryOptions?.queryKey ?? getDailyTodosWidgetsListQueryKey(params)

    const queryFn: QueryFunction<Awaited<ReturnType<typeof dailyTodosWidgetsList>>> = ({ signal }) => dailyTodosWidgetsList(params, requestOptions, signal)

    return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<Awaited<ReturnType<typeof dailyTodosWidgetsList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type DailyTodosWidgetsListQueryResult = NonNullable<Awaited<ReturnType<typeof dailyTodosWidgetsList>>>
export type DailyTodosWidgetsListQueryError = unknown

export function useDailyTodosWidgetsList<TData = Awaited<ReturnType<typeof dailyTodosWidgetsList>>, TError = unknown>(
    params: undefined | DailyTodosWidgetsListParams,
    options: {
        query: Partial<UseQueryOptions<Awaited<ReturnType<typeof dailyTodosWidgetsList>>, TError, TData>> &
            Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof dailyTodosWidgetsList>>, TError, Awaited<ReturnType<typeof dailyTodosWidgetsList>>>, "initialData">
        request?: SecondParameter<typeof customInstance>
    },
    queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useDailyTodosWidgetsList<TData = Awaited<ReturnType<typeof dailyTodosWidgetsList>>, TError = unknown>(
    params?: DailyTodosWidgetsListParams,
    options?: {
        query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof dailyTodosWidgetsList>>, TError, TData>> &
            Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof dailyTodosWidgetsList>>, TError, Awaited<ReturnType<typeof dailyTodosWidgetsList>>>, "initialData">
        request?: SecondParameter<typeof customInstance>
    },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useDailyTodosWidgetsList<TData = Awaited<ReturnType<typeof dailyTodosWidgetsList>>, TError = unknown>(
    params?: DailyTodosWidgetsListParams,
    options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof dailyTodosWidgetsList>>, TError, TData>>; request?: SecondParameter<typeof customInstance> },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useDailyTodosWidgetsList<TData = Awaited<ReturnType<typeof dailyTodosWidgetsList>>, TError = unknown>(
    params?: DailyTodosWidgetsListParams,
    options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof dailyTodosWidgetsList>>, TError, TData>>; request?: SecondParameter<typeof customInstance> },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
    const queryOptions = getDailyTodosWidgetsListQueryOptions(params, options)

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

    query.queryKey = queryOptions.queryKey

    return query
}

export const dailyTodosWidgetsCreate = (createDailyTodosWidget: NonReadonly<CreateDailyTodosWidget>, options?: SecondParameter<typeof customInstance>, signal?: AbortSignal) => {
    return customInstance<CreateDailyTodosWidget>(
        { url: `/api/v1/daily-todos-widgets/`, method: "POST", headers: { "Content-Type": "application/json" }, data: createDailyTodosWidget, signal },
        options
    )
}

export const getDailyTodosWidgetsCreateMutationOptions = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof dailyTodosWidgetsCreate>>, TError, { data: NonReadonly<CreateDailyTodosWidget> }, TContext>
    request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<Awaited<ReturnType<typeof dailyTodosWidgetsCreate>>, TError, { data: NonReadonly<CreateDailyTodosWidget> }, TContext> => {
    const mutationKey = ["dailyTodosWidgetsCreate"]
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined }

    const mutationFn: MutationFunction<Awaited<ReturnType<typeof dailyTodosWidgetsCreate>>, { data: NonReadonly<CreateDailyTodosWidget> }> = (props) => {
        const { data } = props ?? {}

        return dailyTodosWidgetsCreate(data, requestOptions)
    }

    return { mutationFn, ...mutationOptions }
}

export type DailyTodosWidgetsCreateMutationResult = NonNullable<Awaited<ReturnType<typeof dailyTodosWidgetsCreate>>>
export type DailyTodosWidgetsCreateMutationBody = NonReadonly<CreateDailyTodosWidget>
export type DailyTodosWidgetsCreateMutationError = unknown

export const useDailyTodosWidgetsCreate = <TError = unknown, TContext = unknown>(
    options?: {
        mutation?: UseMutationOptions<Awaited<ReturnType<typeof dailyTodosWidgetsCreate>>, TError, { data: NonReadonly<CreateDailyTodosWidget> }, TContext>
        request?: SecondParameter<typeof customInstance>
    },
    queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof dailyTodosWidgetsCreate>>, TError, { data: NonReadonly<CreateDailyTodosWidget> }, TContext> => {
    const mutationOptions = getDailyTodosWidgetsCreateMutationOptions(options)

    return useMutation(mutationOptions, queryClient)
}

export const dailyTodosWidgetsRetrieve = (id: number, options?: SecondParameter<typeof customInstance>, signal?: AbortSignal) => {
    return customInstance<DailyTodosWidget>({ url: `/api/v1/daily-todos-widgets/${id}/`, method: "GET", signal }, options)
}

export const getDailyTodosWidgetsRetrieveQueryKey = (id: number) => {
    return [`/api/v1/daily-todos-widgets/${id}/`] as const
}

export const getDailyTodosWidgetsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof dailyTodosWidgetsRetrieve>>, TError = unknown>(
    id: number,
    options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof dailyTodosWidgetsRetrieve>>, TError, TData>>; request?: SecondParameter<typeof customInstance> }
) => {
    const { query: queryOptions, request: requestOptions } = options ?? {}

    const queryKey = queryOptions?.queryKey ?? getDailyTodosWidgetsRetrieveQueryKey(id)

    const queryFn: QueryFunction<Awaited<ReturnType<typeof dailyTodosWidgetsRetrieve>>> = ({ signal }) => dailyTodosWidgetsRetrieve(id, requestOptions, signal)

    return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<Awaited<ReturnType<typeof dailyTodosWidgetsRetrieve>>, TError, TData> & {
        queryKey: DataTag<QueryKey, TData, TError>
    }
}

export type DailyTodosWidgetsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof dailyTodosWidgetsRetrieve>>>
export type DailyTodosWidgetsRetrieveQueryError = unknown

export function useDailyTodosWidgetsRetrieve<TData = Awaited<ReturnType<typeof dailyTodosWidgetsRetrieve>>, TError = unknown>(
    id: number,
    options: {
        query: Partial<UseQueryOptions<Awaited<ReturnType<typeof dailyTodosWidgetsRetrieve>>, TError, TData>> &
            Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof dailyTodosWidgetsRetrieve>>, TError, Awaited<ReturnType<typeof dailyTodosWidgetsRetrieve>>>, "initialData">
        request?: SecondParameter<typeof customInstance>
    },
    queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useDailyTodosWidgetsRetrieve<TData = Awaited<ReturnType<typeof dailyTodosWidgetsRetrieve>>, TError = unknown>(
    id: number,
    options?: {
        query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof dailyTodosWidgetsRetrieve>>, TError, TData>> &
            Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof dailyTodosWidgetsRetrieve>>, TError, Awaited<ReturnType<typeof dailyTodosWidgetsRetrieve>>>, "initialData">
        request?: SecondParameter<typeof customInstance>
    },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useDailyTodosWidgetsRetrieve<TData = Awaited<ReturnType<typeof dailyTodosWidgetsRetrieve>>, TError = unknown>(
    id: number,
    options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof dailyTodosWidgetsRetrieve>>, TError, TData>>; request?: SecondParameter<typeof customInstance> },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useDailyTodosWidgetsRetrieve<TData = Awaited<ReturnType<typeof dailyTodosWidgetsRetrieve>>, TError = unknown>(
    id: number,
    options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof dailyTodosWidgetsRetrieve>>, TError, TData>>; request?: SecondParameter<typeof customInstance> },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
    const queryOptions = getDailyTodosWidgetsRetrieveQueryOptions(id, options)

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

    query.queryKey = queryOptions.queryKey

    return query
}

export const dailyTodosWidgetsUpdate = (id: number, dailyTodosWidget: NonReadonly<DailyTodosWidget>, options?: SecondParameter<typeof customInstance>) => {
    return customInstance<DailyTodosWidget>({ url: `/api/v1/daily-todos-widgets/${id}/`, method: "PUT", headers: { "Content-Type": "application/json" }, data: dailyTodosWidget }, options)
}

export const getDailyTodosWidgetsUpdateMutationOptions = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof dailyTodosWidgetsUpdate>>, TError, { id: number; data: NonReadonly<DailyTodosWidget> }, TContext>
    request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<Awaited<ReturnType<typeof dailyTodosWidgetsUpdate>>, TError, { id: number; data: NonReadonly<DailyTodosWidget> }, TContext> => {
    const mutationKey = ["dailyTodosWidgetsUpdate"]
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined }

    const mutationFn: MutationFunction<Awaited<ReturnType<typeof dailyTodosWidgetsUpdate>>, { id: number; data: NonReadonly<DailyTodosWidget> }> = (props) => {
        const { id, data } = props ?? {}

        return dailyTodosWidgetsUpdate(id, data, requestOptions)
    }

    return { mutationFn, ...mutationOptions }
}

export type DailyTodosWidgetsUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof dailyTodosWidgetsUpdate>>>
export type DailyTodosWidgetsUpdateMutationBody = NonReadonly<DailyTodosWidget>
export type DailyTodosWidgetsUpdateMutationError = unknown

export const useDailyTodosWidgetsUpdate = <TError = unknown, TContext = unknown>(
    options?: {
        mutation?: UseMutationOptions<Awaited<ReturnType<typeof dailyTodosWidgetsUpdate>>, TError, { id: number; data: NonReadonly<DailyTodosWidget> }, TContext>
        request?: SecondParameter<typeof customInstance>
    },
    queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof dailyTodosWidgetsUpdate>>, TError, { id: number; data: NonReadonly<DailyTodosWidget> }, TContext> => {
    const mutationOptions = getDailyTodosWidgetsUpdateMutationOptions(options)

    return useMutation(mutationOptions, queryClient)
}

export const dailyTodosWidgetsPartialUpdate = (id: number, patchedDailyTodosWidget: NonReadonly<PatchedDailyTodosWidget>, options?: SecondParameter<typeof customInstance>) => {
    return customInstance<DailyTodosWidget>({ url: `/api/v1/daily-todos-widgets/${id}/`, method: "PATCH", headers: { "Content-Type": "application/json" }, data: patchedDailyTodosWidget }, options)
}

export const getDailyTodosWidgetsPartialUpdateMutationOptions = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof dailyTodosWidgetsPartialUpdate>>, TError, { id: number; data: NonReadonly<PatchedDailyTodosWidget> }, TContext>
    request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<Awaited<ReturnType<typeof dailyTodosWidgetsPartialUpdate>>, TError, { id: number; data: NonReadonly<PatchedDailyTodosWidget> }, TContext> => {
    const mutationKey = ["dailyTodosWidgetsPartialUpdate"]
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined }

    const mutationFn: MutationFunction<Awaited<ReturnType<typeof dailyTodosWidgetsPartialUpdate>>, { id: number; data: NonReadonly<PatchedDailyTodosWidget> }> = (props) => {
        const { id, data } = props ?? {}

        return dailyTodosWidgetsPartialUpdate(id, data, requestOptions)
    }

    return { mutationFn, ...mutationOptions }
}

export type DailyTodosWidgetsPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof dailyTodosWidgetsPartialUpdate>>>
export type DailyTodosWidgetsPartialUpdateMutationBody = NonReadonly<PatchedDailyTodosWidget>
export type DailyTodosWidgetsPartialUpdateMutationError = unknown

export const useDailyTodosWidgetsPartialUpdate = <TError = unknown, TContext = unknown>(
    options?: {
        mutation?: UseMutationOptions<Awaited<ReturnType<typeof dailyTodosWidgetsPartialUpdate>>, TError, { id: number; data: NonReadonly<PatchedDailyTodosWidget> }, TContext>
        request?: SecondParameter<typeof customInstance>
    },
    queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof dailyTodosWidgetsPartialUpdate>>, TError, { id: number; data: NonReadonly<PatchedDailyTodosWidget> }, TContext> => {
    const mutationOptions = getDailyTodosWidgetsPartialUpdateMutationOptions(options)

    return useMutation(mutationOptions, queryClient)
}

export const dailyTodosWidgetsDestroy = (id: number, options?: SecondParameter<typeof customInstance>) => {
    return customInstance<void>({ url: `/api/v1/daily-todos-widgets/${id}/`, method: "DELETE" }, options)
}

export const getDailyTodosWidgetsDestroyMutationOptions = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof dailyTodosWidgetsDestroy>>, TError, { id: number }, TContext>
    request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<Awaited<ReturnType<typeof dailyTodosWidgetsDestroy>>, TError, { id: number }, TContext> => {
    const mutationKey = ["dailyTodosWidgetsDestroy"]
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined }

    const mutationFn: MutationFunction<Awaited<ReturnType<typeof dailyTodosWidgetsDestroy>>, { id: number }> = (props) => {
        const { id } = props ?? {}

        return dailyTodosWidgetsDestroy(id, requestOptions)
    }

    return { mutationFn, ...mutationOptions }
}

export type DailyTodosWidgetsDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof dailyTodosWidgetsDestroy>>>

export type DailyTodosWidgetsDestroyMutationError = unknown

export const useDailyTodosWidgetsDestroy = <TError = unknown, TContext = unknown>(
    options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof dailyTodosWidgetsDestroy>>, TError, { id: number }, TContext>; request?: SecondParameter<typeof customInstance> },
    queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof dailyTodosWidgetsDestroy>>, TError, { id: number }, TContext> => {
    const mutationOptions = getDailyTodosWidgetsDestroyMutationOptions(options)

    return useMutation(mutationOptions, queryClient)
}

export const fileUploadsCreate = (fileUpload: NonReadonly<FileUpload>, options?: SecondParameter<typeof customInstance>, signal?: AbortSignal) => {
    return customInstance<FileUpload>({ url: `/api/v1/file-uploads/`, method: "POST", headers: { "Content-Type": "application/json" }, data: fileUpload, signal }, options)
}

export const getFileUploadsCreateMutationOptions = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof fileUploadsCreate>>, TError, { data: NonReadonly<FileUpload> }, TContext>
    request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<Awaited<ReturnType<typeof fileUploadsCreate>>, TError, { data: NonReadonly<FileUpload> }, TContext> => {
    const mutationKey = ["fileUploadsCreate"]
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined }

    const mutationFn: MutationFunction<Awaited<ReturnType<typeof fileUploadsCreate>>, { data: NonReadonly<FileUpload> }> = (props) => {
        const { data } = props ?? {}

        return fileUploadsCreate(data, requestOptions)
    }

    return { mutationFn, ...mutationOptions }
}

export type FileUploadsCreateMutationResult = NonNullable<Awaited<ReturnType<typeof fileUploadsCreate>>>
export type FileUploadsCreateMutationBody = NonReadonly<FileUpload>
export type FileUploadsCreateMutationError = unknown

export const useFileUploadsCreate = <TError = unknown, TContext = unknown>(
    options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof fileUploadsCreate>>, TError, { data: NonReadonly<FileUpload> }, TContext>; request?: SecondParameter<typeof customInstance> },
    queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof fileUploadsCreate>>, TError, { data: NonReadonly<FileUpload> }, TContext> => {
    const mutationOptions = getFileUploadsCreateMutationOptions(options)

    return useMutation(mutationOptions, queryClient)
}

export const inspirationItemsList = (params?: InspirationItemsListParams, options?: SecondParameter<typeof customInstance>, signal?: AbortSignal) => {
    return customInstance<PaginatedInspirationItemList>({ url: `/api/v1/inspiration-items/`, method: "GET", params, signal }, options)
}

export const getInspirationItemsListQueryKey = (params?: InspirationItemsListParams) => {
    return [`/api/v1/inspiration-items/`, ...(params ? [params] : [])] as const
}

export const getInspirationItemsListQueryOptions = <TData = Awaited<ReturnType<typeof inspirationItemsList>>, TError = unknown>(
    params?: InspirationItemsListParams,
    options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof inspirationItemsList>>, TError, TData>>; request?: SecondParameter<typeof customInstance> }
) => {
    const { query: queryOptions, request: requestOptions } = options ?? {}

    const queryKey = queryOptions?.queryKey ?? getInspirationItemsListQueryKey(params)

    const queryFn: QueryFunction<Awaited<ReturnType<typeof inspirationItemsList>>> = ({ signal }) => inspirationItemsList(params, requestOptions, signal)

    return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<Awaited<ReturnType<typeof inspirationItemsList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type InspirationItemsListQueryResult = NonNullable<Awaited<ReturnType<typeof inspirationItemsList>>>
export type InspirationItemsListQueryError = unknown

export function useInspirationItemsList<TData = Awaited<ReturnType<typeof inspirationItemsList>>, TError = unknown>(
    params: undefined | InspirationItemsListParams,
    options: {
        query: Partial<UseQueryOptions<Awaited<ReturnType<typeof inspirationItemsList>>, TError, TData>> &
            Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof inspirationItemsList>>, TError, Awaited<ReturnType<typeof inspirationItemsList>>>, "initialData">
        request?: SecondParameter<typeof customInstance>
    },
    queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useInspirationItemsList<TData = Awaited<ReturnType<typeof inspirationItemsList>>, TError = unknown>(
    params?: InspirationItemsListParams,
    options?: {
        query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof inspirationItemsList>>, TError, TData>> &
            Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof inspirationItemsList>>, TError, Awaited<ReturnType<typeof inspirationItemsList>>>, "initialData">
        request?: SecondParameter<typeof customInstance>
    },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useInspirationItemsList<TData = Awaited<ReturnType<typeof inspirationItemsList>>, TError = unknown>(
    params?: InspirationItemsListParams,
    options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof inspirationItemsList>>, TError, TData>>; request?: SecondParameter<typeof customInstance> },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useInspirationItemsList<TData = Awaited<ReturnType<typeof inspirationItemsList>>, TError = unknown>(
    params?: InspirationItemsListParams,
    options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof inspirationItemsList>>, TError, TData>>; request?: SecondParameter<typeof customInstance> },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
    const queryOptions = getInspirationItemsListQueryOptions(params, options)

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

    query.queryKey = queryOptions.queryKey

    return query
}

export const inspirationItemsCreate = (createInspirationItem: NonReadonly<CreateInspirationItem>, options?: SecondParameter<typeof customInstance>, signal?: AbortSignal) => {
    return customInstance<CreateInspirationItem>({ url: `/api/v1/inspiration-items/`, method: "POST", headers: { "Content-Type": "application/json" }, data: createInspirationItem, signal }, options)
}

export const getInspirationItemsCreateMutationOptions = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof inspirationItemsCreate>>, TError, { data: NonReadonly<CreateInspirationItem> }, TContext>
    request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<Awaited<ReturnType<typeof inspirationItemsCreate>>, TError, { data: NonReadonly<CreateInspirationItem> }, TContext> => {
    const mutationKey = ["inspirationItemsCreate"]
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined }

    const mutationFn: MutationFunction<Awaited<ReturnType<typeof inspirationItemsCreate>>, { data: NonReadonly<CreateInspirationItem> }> = (props) => {
        const { data } = props ?? {}

        return inspirationItemsCreate(data, requestOptions)
    }

    return { mutationFn, ...mutationOptions }
}

export type InspirationItemsCreateMutationResult = NonNullable<Awaited<ReturnType<typeof inspirationItemsCreate>>>
export type InspirationItemsCreateMutationBody = NonReadonly<CreateInspirationItem>
export type InspirationItemsCreateMutationError = unknown

export const useInspirationItemsCreate = <TError = unknown, TContext = unknown>(
    options?: {
        mutation?: UseMutationOptions<Awaited<ReturnType<typeof inspirationItemsCreate>>, TError, { data: NonReadonly<CreateInspirationItem> }, TContext>
        request?: SecondParameter<typeof customInstance>
    },
    queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof inspirationItemsCreate>>, TError, { data: NonReadonly<CreateInspirationItem> }, TContext> => {
    const mutationOptions = getInspirationItemsCreateMutationOptions(options)

    return useMutation(mutationOptions, queryClient)
}

export const inspirationModulesList = (params?: InspirationModulesListParams, options?: SecondParameter<typeof customInstance>, signal?: AbortSignal) => {
    return customInstance<PaginatedInspirationModuleList>({ url: `/api/v1/inspiration-modules/`, method: "GET", params, signal }, options)
}

export const getInspirationModulesListQueryKey = (params?: InspirationModulesListParams) => {
    return [`/api/v1/inspiration-modules/`, ...(params ? [params] : [])] as const
}

export const getInspirationModulesListQueryOptions = <TData = Awaited<ReturnType<typeof inspirationModulesList>>, TError = unknown>(
    params?: InspirationModulesListParams,
    options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof inspirationModulesList>>, TError, TData>>; request?: SecondParameter<typeof customInstance> }
) => {
    const { query: queryOptions, request: requestOptions } = options ?? {}

    const queryKey = queryOptions?.queryKey ?? getInspirationModulesListQueryKey(params)

    const queryFn: QueryFunction<Awaited<ReturnType<typeof inspirationModulesList>>> = ({ signal }) => inspirationModulesList(params, requestOptions, signal)

    return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<Awaited<ReturnType<typeof inspirationModulesList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type InspirationModulesListQueryResult = NonNullable<Awaited<ReturnType<typeof inspirationModulesList>>>
export type InspirationModulesListQueryError = unknown

export function useInspirationModulesList<TData = Awaited<ReturnType<typeof inspirationModulesList>>, TError = unknown>(
    params: undefined | InspirationModulesListParams,
    options: {
        query: Partial<UseQueryOptions<Awaited<ReturnType<typeof inspirationModulesList>>, TError, TData>> &
            Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof inspirationModulesList>>, TError, Awaited<ReturnType<typeof inspirationModulesList>>>, "initialData">
        request?: SecondParameter<typeof customInstance>
    },
    queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useInspirationModulesList<TData = Awaited<ReturnType<typeof inspirationModulesList>>, TError = unknown>(
    params?: InspirationModulesListParams,
    options?: {
        query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof inspirationModulesList>>, TError, TData>> &
            Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof inspirationModulesList>>, TError, Awaited<ReturnType<typeof inspirationModulesList>>>, "initialData">
        request?: SecondParameter<typeof customInstance>
    },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useInspirationModulesList<TData = Awaited<ReturnType<typeof inspirationModulesList>>, TError = unknown>(
    params?: InspirationModulesListParams,
    options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof inspirationModulesList>>, TError, TData>>; request?: SecondParameter<typeof customInstance> },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useInspirationModulesList<TData = Awaited<ReturnType<typeof inspirationModulesList>>, TError = unknown>(
    params?: InspirationModulesListParams,
    options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof inspirationModulesList>>, TError, TData>>; request?: SecondParameter<typeof customInstance> },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
    const queryOptions = getInspirationModulesListQueryOptions(params, options)

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

    query.queryKey = queryOptions.queryKey

    return query
}

export const inspirationModulesCreate = (inspirationModule: NonReadonly<InspirationModule>, options?: SecondParameter<typeof customInstance>, signal?: AbortSignal) => {
    return customInstance<InspirationModule>({ url: `/api/v1/inspiration-modules/`, method: "POST", headers: { "Content-Type": "application/json" }, data: inspirationModule, signal }, options)
}

export const getInspirationModulesCreateMutationOptions = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof inspirationModulesCreate>>, TError, { data: NonReadonly<InspirationModule> }, TContext>
    request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<Awaited<ReturnType<typeof inspirationModulesCreate>>, TError, { data: NonReadonly<InspirationModule> }, TContext> => {
    const mutationKey = ["inspirationModulesCreate"]
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined }

    const mutationFn: MutationFunction<Awaited<ReturnType<typeof inspirationModulesCreate>>, { data: NonReadonly<InspirationModule> }> = (props) => {
        const { data } = props ?? {}

        return inspirationModulesCreate(data, requestOptions)
    }

    return { mutationFn, ...mutationOptions }
}

export type InspirationModulesCreateMutationResult = NonNullable<Awaited<ReturnType<typeof inspirationModulesCreate>>>
export type InspirationModulesCreateMutationBody = NonReadonly<InspirationModule>
export type InspirationModulesCreateMutationError = unknown

export const useInspirationModulesCreate = <TError = unknown, TContext = unknown>(
    options?: {
        mutation?: UseMutationOptions<Awaited<ReturnType<typeof inspirationModulesCreate>>, TError, { data: NonReadonly<InspirationModule> }, TContext>
        request?: SecondParameter<typeof customInstance>
    },
    queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof inspirationModulesCreate>>, TError, { data: NonReadonly<InspirationModule> }, TContext> => {
    const mutationOptions = getInspirationModulesCreateMutationOptions(options)

    return useMutation(mutationOptions, queryClient)
}

export const inspirationModulesRetrieve = (id: number, options?: SecondParameter<typeof customInstance>, signal?: AbortSignal) => {
    return customInstance<InspirationModule>({ url: `/api/v1/inspiration-modules/${id}/`, method: "GET", signal }, options)
}

export const getInspirationModulesRetrieveQueryKey = (id: number) => {
    return [`/api/v1/inspiration-modules/${id}/`] as const
}

export const getInspirationModulesRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof inspirationModulesRetrieve>>, TError = unknown>(
    id: number,
    options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof inspirationModulesRetrieve>>, TError, TData>>; request?: SecondParameter<typeof customInstance> }
) => {
    const { query: queryOptions, request: requestOptions } = options ?? {}

    const queryKey = queryOptions?.queryKey ?? getInspirationModulesRetrieveQueryKey(id)

    const queryFn: QueryFunction<Awaited<ReturnType<typeof inspirationModulesRetrieve>>> = ({ signal }) => inspirationModulesRetrieve(id, requestOptions, signal)

    return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<Awaited<ReturnType<typeof inspirationModulesRetrieve>>, TError, TData> & {
        queryKey: DataTag<QueryKey, TData, TError>
    }
}

export type InspirationModulesRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof inspirationModulesRetrieve>>>
export type InspirationModulesRetrieveQueryError = unknown

export function useInspirationModulesRetrieve<TData = Awaited<ReturnType<typeof inspirationModulesRetrieve>>, TError = unknown>(
    id: number,
    options: {
        query: Partial<UseQueryOptions<Awaited<ReturnType<typeof inspirationModulesRetrieve>>, TError, TData>> &
            Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof inspirationModulesRetrieve>>, TError, Awaited<ReturnType<typeof inspirationModulesRetrieve>>>, "initialData">
        request?: SecondParameter<typeof customInstance>
    },
    queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useInspirationModulesRetrieve<TData = Awaited<ReturnType<typeof inspirationModulesRetrieve>>, TError = unknown>(
    id: number,
    options?: {
        query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof inspirationModulesRetrieve>>, TError, TData>> &
            Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof inspirationModulesRetrieve>>, TError, Awaited<ReturnType<typeof inspirationModulesRetrieve>>>, "initialData">
        request?: SecondParameter<typeof customInstance>
    },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useInspirationModulesRetrieve<TData = Awaited<ReturnType<typeof inspirationModulesRetrieve>>, TError = unknown>(
    id: number,
    options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof inspirationModulesRetrieve>>, TError, TData>>; request?: SecondParameter<typeof customInstance> },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useInspirationModulesRetrieve<TData = Awaited<ReturnType<typeof inspirationModulesRetrieve>>, TError = unknown>(
    id: number,
    options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof inspirationModulesRetrieve>>, TError, TData>>; request?: SecondParameter<typeof customInstance> },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
    const queryOptions = getInspirationModulesRetrieveQueryOptions(id, options)

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

    query.queryKey = queryOptions.queryKey

    return query
}

export const inspirationModulesUpdate = (id: number, inspirationModule: NonReadonly<InspirationModule>, options?: SecondParameter<typeof customInstance>) => {
    return customInstance<InspirationModule>({ url: `/api/v1/inspiration-modules/${id}/`, method: "PUT", headers: { "Content-Type": "application/json" }, data: inspirationModule }, options)
}

export const getInspirationModulesUpdateMutationOptions = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof inspirationModulesUpdate>>, TError, { id: number; data: NonReadonly<InspirationModule> }, TContext>
    request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<Awaited<ReturnType<typeof inspirationModulesUpdate>>, TError, { id: number; data: NonReadonly<InspirationModule> }, TContext> => {
    const mutationKey = ["inspirationModulesUpdate"]
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined }

    const mutationFn: MutationFunction<Awaited<ReturnType<typeof inspirationModulesUpdate>>, { id: number; data: NonReadonly<InspirationModule> }> = (props) => {
        const { id, data } = props ?? {}

        return inspirationModulesUpdate(id, data, requestOptions)
    }

    return { mutationFn, ...mutationOptions }
}

export type InspirationModulesUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof inspirationModulesUpdate>>>
export type InspirationModulesUpdateMutationBody = NonReadonly<InspirationModule>
export type InspirationModulesUpdateMutationError = unknown

export const useInspirationModulesUpdate = <TError = unknown, TContext = unknown>(
    options?: {
        mutation?: UseMutationOptions<Awaited<ReturnType<typeof inspirationModulesUpdate>>, TError, { id: number; data: NonReadonly<InspirationModule> }, TContext>
        request?: SecondParameter<typeof customInstance>
    },
    queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof inspirationModulesUpdate>>, TError, { id: number; data: NonReadonly<InspirationModule> }, TContext> => {
    const mutationOptions = getInspirationModulesUpdateMutationOptions(options)

    return useMutation(mutationOptions, queryClient)
}

export const inspirationModulesPartialUpdate = (id: number, patchedInspirationModule: NonReadonly<PatchedInspirationModule>, options?: SecondParameter<typeof customInstance>) => {
    return customInstance<InspirationModule>({ url: `/api/v1/inspiration-modules/${id}/`, method: "PATCH", headers: { "Content-Type": "application/json" }, data: patchedInspirationModule }, options)
}

export const getInspirationModulesPartialUpdateMutationOptions = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof inspirationModulesPartialUpdate>>, TError, { id: number; data: NonReadonly<PatchedInspirationModule> }, TContext>
    request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<Awaited<ReturnType<typeof inspirationModulesPartialUpdate>>, TError, { id: number; data: NonReadonly<PatchedInspirationModule> }, TContext> => {
    const mutationKey = ["inspirationModulesPartialUpdate"]
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined }

    const mutationFn: MutationFunction<Awaited<ReturnType<typeof inspirationModulesPartialUpdate>>, { id: number; data: NonReadonly<PatchedInspirationModule> }> = (props) => {
        const { id, data } = props ?? {}

        return inspirationModulesPartialUpdate(id, data, requestOptions)
    }

    return { mutationFn, ...mutationOptions }
}

export type InspirationModulesPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof inspirationModulesPartialUpdate>>>
export type InspirationModulesPartialUpdateMutationBody = NonReadonly<PatchedInspirationModule>
export type InspirationModulesPartialUpdateMutationError = unknown

export const useInspirationModulesPartialUpdate = <TError = unknown, TContext = unknown>(
    options?: {
        mutation?: UseMutationOptions<Awaited<ReturnType<typeof inspirationModulesPartialUpdate>>, TError, { id: number; data: NonReadonly<PatchedInspirationModule> }, TContext>
        request?: SecondParameter<typeof customInstance>
    },
    queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof inspirationModulesPartialUpdate>>, TError, { id: number; data: NonReadonly<PatchedInspirationModule> }, TContext> => {
    const mutationOptions = getInspirationModulesPartialUpdateMutationOptions(options)

    return useMutation(mutationOptions, queryClient)
}

export const inspirationModulesDestroy = (id: number, options?: SecondParameter<typeof customInstance>) => {
    return customInstance<void>({ url: `/api/v1/inspiration-modules/${id}/`, method: "DELETE" }, options)
}

export const getInspirationModulesDestroyMutationOptions = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof inspirationModulesDestroy>>, TError, { id: number }, TContext>
    request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<Awaited<ReturnType<typeof inspirationModulesDestroy>>, TError, { id: number }, TContext> => {
    const mutationKey = ["inspirationModulesDestroy"]
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined }

    const mutationFn: MutationFunction<Awaited<ReturnType<typeof inspirationModulesDestroy>>, { id: number }> = (props) => {
        const { id } = props ?? {}

        return inspirationModulesDestroy(id, requestOptions)
    }

    return { mutationFn, ...mutationOptions }
}

export type InspirationModulesDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof inspirationModulesDestroy>>>

export type InspirationModulesDestroyMutationError = unknown

export const useInspirationModulesDestroy = <TError = unknown, TContext = unknown>(
    options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof inspirationModulesDestroy>>, TError, { id: number }, TContext>; request?: SecondParameter<typeof customInstance> },
    queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof inspirationModulesDestroy>>, TError, { id: number }, TContext> => {
    const mutationOptions = getInspirationModulesDestroyMutationOptions(options)

    return useMutation(mutationOptions, queryClient)
}

export const inspirationOptionsList = (params?: InspirationOptionsListParams, options?: SecondParameter<typeof customInstance>, signal?: AbortSignal) => {
    return customInstance<PaginatedInspirationOptionList>({ url: `/api/v1/inspiration-options/`, method: "GET", params, signal }, options)
}

export const getInspirationOptionsListQueryKey = (params?: InspirationOptionsListParams) => {
    return [`/api/v1/inspiration-options/`, ...(params ? [params] : [])] as const
}

export const getInspirationOptionsListQueryOptions = <TData = Awaited<ReturnType<typeof inspirationOptionsList>>, TError = unknown>(
    params?: InspirationOptionsListParams,
    options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof inspirationOptionsList>>, TError, TData>>; request?: SecondParameter<typeof customInstance> }
) => {
    const { query: queryOptions, request: requestOptions } = options ?? {}

    const queryKey = queryOptions?.queryKey ?? getInspirationOptionsListQueryKey(params)

    const queryFn: QueryFunction<Awaited<ReturnType<typeof inspirationOptionsList>>> = ({ signal }) => inspirationOptionsList(params, requestOptions, signal)

    return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<Awaited<ReturnType<typeof inspirationOptionsList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type InspirationOptionsListQueryResult = NonNullable<Awaited<ReturnType<typeof inspirationOptionsList>>>
export type InspirationOptionsListQueryError = unknown

export function useInspirationOptionsList<TData = Awaited<ReturnType<typeof inspirationOptionsList>>, TError = unknown>(
    params: undefined | InspirationOptionsListParams,
    options: {
        query: Partial<UseQueryOptions<Awaited<ReturnType<typeof inspirationOptionsList>>, TError, TData>> &
            Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof inspirationOptionsList>>, TError, Awaited<ReturnType<typeof inspirationOptionsList>>>, "initialData">
        request?: SecondParameter<typeof customInstance>
    },
    queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useInspirationOptionsList<TData = Awaited<ReturnType<typeof inspirationOptionsList>>, TError = unknown>(
    params?: InspirationOptionsListParams,
    options?: {
        query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof inspirationOptionsList>>, TError, TData>> &
            Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof inspirationOptionsList>>, TError, Awaited<ReturnType<typeof inspirationOptionsList>>>, "initialData">
        request?: SecondParameter<typeof customInstance>
    },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useInspirationOptionsList<TData = Awaited<ReturnType<typeof inspirationOptionsList>>, TError = unknown>(
    params?: InspirationOptionsListParams,
    options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof inspirationOptionsList>>, TError, TData>>; request?: SecondParameter<typeof customInstance> },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useInspirationOptionsList<TData = Awaited<ReturnType<typeof inspirationOptionsList>>, TError = unknown>(
    params?: InspirationOptionsListParams,
    options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof inspirationOptionsList>>, TError, TData>>; request?: SecondParameter<typeof customInstance> },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
    const queryOptions = getInspirationOptionsListQueryOptions(params, options)

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

    query.queryKey = queryOptions.queryKey

    return query
}

export const inspirationOptionsCreate = (createInspirationOption: NonReadonly<CreateInspirationOption>, options?: SecondParameter<typeof customInstance>, signal?: AbortSignal) => {
    return customInstance<CreateInspirationOption>(
        { url: `/api/v1/inspiration-options/`, method: "POST", headers: { "Content-Type": "application/json" }, data: createInspirationOption, signal },
        options
    )
}

export const getInspirationOptionsCreateMutationOptions = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof inspirationOptionsCreate>>, TError, { data: NonReadonly<CreateInspirationOption> }, TContext>
    request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<Awaited<ReturnType<typeof inspirationOptionsCreate>>, TError, { data: NonReadonly<CreateInspirationOption> }, TContext> => {
    const mutationKey = ["inspirationOptionsCreate"]
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined }

    const mutationFn: MutationFunction<Awaited<ReturnType<typeof inspirationOptionsCreate>>, { data: NonReadonly<CreateInspirationOption> }> = (props) => {
        const { data } = props ?? {}

        return inspirationOptionsCreate(data, requestOptions)
    }

    return { mutationFn, ...mutationOptions }
}

export type InspirationOptionsCreateMutationResult = NonNullable<Awaited<ReturnType<typeof inspirationOptionsCreate>>>
export type InspirationOptionsCreateMutationBody = NonReadonly<CreateInspirationOption>
export type InspirationOptionsCreateMutationError = unknown

export const useInspirationOptionsCreate = <TError = unknown, TContext = unknown>(
    options?: {
        mutation?: UseMutationOptions<Awaited<ReturnType<typeof inspirationOptionsCreate>>, TError, { data: NonReadonly<CreateInspirationOption> }, TContext>
        request?: SecondParameter<typeof customInstance>
    },
    queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof inspirationOptionsCreate>>, TError, { data: NonReadonly<CreateInspirationOption> }, TContext> => {
    const mutationOptions = getInspirationOptionsCreateMutationOptions(options)

    return useMutation(mutationOptions, queryClient)
}

export const inspirationOptionsRetrieve = (id: number, options?: SecondParameter<typeof customInstance>, signal?: AbortSignal) => {
    return customInstance<InspirationOption>({ url: `/api/v1/inspiration-options/${id}/`, method: "GET", signal }, options)
}

export const getInspirationOptionsRetrieveQueryKey = (id: number) => {
    return [`/api/v1/inspiration-options/${id}/`] as const
}

export const getInspirationOptionsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof inspirationOptionsRetrieve>>, TError = unknown>(
    id: number,
    options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof inspirationOptionsRetrieve>>, TError, TData>>; request?: SecondParameter<typeof customInstance> }
) => {
    const { query: queryOptions, request: requestOptions } = options ?? {}

    const queryKey = queryOptions?.queryKey ?? getInspirationOptionsRetrieveQueryKey(id)

    const queryFn: QueryFunction<Awaited<ReturnType<typeof inspirationOptionsRetrieve>>> = ({ signal }) => inspirationOptionsRetrieve(id, requestOptions, signal)

    return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<Awaited<ReturnType<typeof inspirationOptionsRetrieve>>, TError, TData> & {
        queryKey: DataTag<QueryKey, TData, TError>
    }
}

export type InspirationOptionsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof inspirationOptionsRetrieve>>>
export type InspirationOptionsRetrieveQueryError = unknown

export function useInspirationOptionsRetrieve<TData = Awaited<ReturnType<typeof inspirationOptionsRetrieve>>, TError = unknown>(
    id: number,
    options: {
        query: Partial<UseQueryOptions<Awaited<ReturnType<typeof inspirationOptionsRetrieve>>, TError, TData>> &
            Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof inspirationOptionsRetrieve>>, TError, Awaited<ReturnType<typeof inspirationOptionsRetrieve>>>, "initialData">
        request?: SecondParameter<typeof customInstance>
    },
    queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useInspirationOptionsRetrieve<TData = Awaited<ReturnType<typeof inspirationOptionsRetrieve>>, TError = unknown>(
    id: number,
    options?: {
        query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof inspirationOptionsRetrieve>>, TError, TData>> &
            Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof inspirationOptionsRetrieve>>, TError, Awaited<ReturnType<typeof inspirationOptionsRetrieve>>>, "initialData">
        request?: SecondParameter<typeof customInstance>
    },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useInspirationOptionsRetrieve<TData = Awaited<ReturnType<typeof inspirationOptionsRetrieve>>, TError = unknown>(
    id: number,
    options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof inspirationOptionsRetrieve>>, TError, TData>>; request?: SecondParameter<typeof customInstance> },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useInspirationOptionsRetrieve<TData = Awaited<ReturnType<typeof inspirationOptionsRetrieve>>, TError = unknown>(
    id: number,
    options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof inspirationOptionsRetrieve>>, TError, TData>>; request?: SecondParameter<typeof customInstance> },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
    const queryOptions = getInspirationOptionsRetrieveQueryOptions(id, options)

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

    query.queryKey = queryOptions.queryKey

    return query
}

export const inspirationOptionsUpdate = (id: number, inspirationOption: NonReadonly<InspirationOption>, options?: SecondParameter<typeof customInstance>) => {
    return customInstance<InspirationOption>({ url: `/api/v1/inspiration-options/${id}/`, method: "PUT", headers: { "Content-Type": "application/json" }, data: inspirationOption }, options)
}

export const getInspirationOptionsUpdateMutationOptions = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof inspirationOptionsUpdate>>, TError, { id: number; data: NonReadonly<InspirationOption> }, TContext>
    request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<Awaited<ReturnType<typeof inspirationOptionsUpdate>>, TError, { id: number; data: NonReadonly<InspirationOption> }, TContext> => {
    const mutationKey = ["inspirationOptionsUpdate"]
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined }

    const mutationFn: MutationFunction<Awaited<ReturnType<typeof inspirationOptionsUpdate>>, { id: number; data: NonReadonly<InspirationOption> }> = (props) => {
        const { id, data } = props ?? {}

        return inspirationOptionsUpdate(id, data, requestOptions)
    }

    return { mutationFn, ...mutationOptions }
}

export type InspirationOptionsUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof inspirationOptionsUpdate>>>
export type InspirationOptionsUpdateMutationBody = NonReadonly<InspirationOption>
export type InspirationOptionsUpdateMutationError = unknown

export const useInspirationOptionsUpdate = <TError = unknown, TContext = unknown>(
    options?: {
        mutation?: UseMutationOptions<Awaited<ReturnType<typeof inspirationOptionsUpdate>>, TError, { id: number; data: NonReadonly<InspirationOption> }, TContext>
        request?: SecondParameter<typeof customInstance>
    },
    queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof inspirationOptionsUpdate>>, TError, { id: number; data: NonReadonly<InspirationOption> }, TContext> => {
    const mutationOptions = getInspirationOptionsUpdateMutationOptions(options)

    return useMutation(mutationOptions, queryClient)
}

export const inspirationOptionsPartialUpdate = (id: number, patchedInspirationOption: NonReadonly<PatchedInspirationOption>, options?: SecondParameter<typeof customInstance>) => {
    return customInstance<InspirationOption>({ url: `/api/v1/inspiration-options/${id}/`, method: "PATCH", headers: { "Content-Type": "application/json" }, data: patchedInspirationOption }, options)
}

export const getInspirationOptionsPartialUpdateMutationOptions = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof inspirationOptionsPartialUpdate>>, TError, { id: number; data: NonReadonly<PatchedInspirationOption> }, TContext>
    request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<Awaited<ReturnType<typeof inspirationOptionsPartialUpdate>>, TError, { id: number; data: NonReadonly<PatchedInspirationOption> }, TContext> => {
    const mutationKey = ["inspirationOptionsPartialUpdate"]
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined }

    const mutationFn: MutationFunction<Awaited<ReturnType<typeof inspirationOptionsPartialUpdate>>, { id: number; data: NonReadonly<PatchedInspirationOption> }> = (props) => {
        const { id, data } = props ?? {}

        return inspirationOptionsPartialUpdate(id, data, requestOptions)
    }

    return { mutationFn, ...mutationOptions }
}

export type InspirationOptionsPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof inspirationOptionsPartialUpdate>>>
export type InspirationOptionsPartialUpdateMutationBody = NonReadonly<PatchedInspirationOption>
export type InspirationOptionsPartialUpdateMutationError = unknown

export const useInspirationOptionsPartialUpdate = <TError = unknown, TContext = unknown>(
    options?: {
        mutation?: UseMutationOptions<Awaited<ReturnType<typeof inspirationOptionsPartialUpdate>>, TError, { id: number; data: NonReadonly<PatchedInspirationOption> }, TContext>
        request?: SecondParameter<typeof customInstance>
    },
    queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof inspirationOptionsPartialUpdate>>, TError, { id: number; data: NonReadonly<PatchedInspirationOption> }, TContext> => {
    const mutationOptions = getInspirationOptionsPartialUpdateMutationOptions(options)

    return useMutation(mutationOptions, queryClient)
}

export const inspirationOptionsDestroy = (id: number, options?: SecondParameter<typeof customInstance>) => {
    return customInstance<void>({ url: `/api/v1/inspiration-options/${id}/`, method: "DELETE" }, options)
}

export const getInspirationOptionsDestroyMutationOptions = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof inspirationOptionsDestroy>>, TError, { id: number }, TContext>
    request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<Awaited<ReturnType<typeof inspirationOptionsDestroy>>, TError, { id: number }, TContext> => {
    const mutationKey = ["inspirationOptionsDestroy"]
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined }

    const mutationFn: MutationFunction<Awaited<ReturnType<typeof inspirationOptionsDestroy>>, { id: number }> = (props) => {
        const { id } = props ?? {}

        return inspirationOptionsDestroy(id, requestOptions)
    }

    return { mutationFn, ...mutationOptions }
}

export type InspirationOptionsDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof inspirationOptionsDestroy>>>

export type InspirationOptionsDestroyMutationError = unknown

export const useInspirationOptionsDestroy = <TError = unknown, TContext = unknown>(
    options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof inspirationOptionsDestroy>>, TError, { id: number }, TContext>; request?: SecondParameter<typeof customInstance> },
    queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof inspirationOptionsDestroy>>, TError, { id: number }, TContext> => {
    const mutationOptions = getInspirationOptionsDestroyMutationOptions(options)

    return useMutation(mutationOptions, queryClient)
}

export const inspirationWidgetsList = (params?: InspirationWidgetsListParams, options?: SecondParameter<typeof customInstance>, signal?: AbortSignal) => {
    return customInstance<PaginatedInspirationWidgetList>({ url: `/api/v1/inspiration-widgets/`, method: "GET", params, signal }, options)
}

export const getInspirationWidgetsListQueryKey = (params?: InspirationWidgetsListParams) => {
    return [`/api/v1/inspiration-widgets/`, ...(params ? [params] : [])] as const
}

export const getInspirationWidgetsListQueryOptions = <TData = Awaited<ReturnType<typeof inspirationWidgetsList>>, TError = unknown>(
    params?: InspirationWidgetsListParams,
    options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof inspirationWidgetsList>>, TError, TData>>; request?: SecondParameter<typeof customInstance> }
) => {
    const { query: queryOptions, request: requestOptions } = options ?? {}

    const queryKey = queryOptions?.queryKey ?? getInspirationWidgetsListQueryKey(params)

    const queryFn: QueryFunction<Awaited<ReturnType<typeof inspirationWidgetsList>>> = ({ signal }) => inspirationWidgetsList(params, requestOptions, signal)

    return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<Awaited<ReturnType<typeof inspirationWidgetsList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type InspirationWidgetsListQueryResult = NonNullable<Awaited<ReturnType<typeof inspirationWidgetsList>>>
export type InspirationWidgetsListQueryError = unknown

export function useInspirationWidgetsList<TData = Awaited<ReturnType<typeof inspirationWidgetsList>>, TError = unknown>(
    params: undefined | InspirationWidgetsListParams,
    options: {
        query: Partial<UseQueryOptions<Awaited<ReturnType<typeof inspirationWidgetsList>>, TError, TData>> &
            Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof inspirationWidgetsList>>, TError, Awaited<ReturnType<typeof inspirationWidgetsList>>>, "initialData">
        request?: SecondParameter<typeof customInstance>
    },
    queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useInspirationWidgetsList<TData = Awaited<ReturnType<typeof inspirationWidgetsList>>, TError = unknown>(
    params?: InspirationWidgetsListParams,
    options?: {
        query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof inspirationWidgetsList>>, TError, TData>> &
            Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof inspirationWidgetsList>>, TError, Awaited<ReturnType<typeof inspirationWidgetsList>>>, "initialData">
        request?: SecondParameter<typeof customInstance>
    },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useInspirationWidgetsList<TData = Awaited<ReturnType<typeof inspirationWidgetsList>>, TError = unknown>(
    params?: InspirationWidgetsListParams,
    options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof inspirationWidgetsList>>, TError, TData>>; request?: SecondParameter<typeof customInstance> },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useInspirationWidgetsList<TData = Awaited<ReturnType<typeof inspirationWidgetsList>>, TError = unknown>(
    params?: InspirationWidgetsListParams,
    options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof inspirationWidgetsList>>, TError, TData>>; request?: SecondParameter<typeof customInstance> },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
    const queryOptions = getInspirationWidgetsListQueryOptions(params, options)

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

    query.queryKey = queryOptions.queryKey

    return query
}

export const inspirationWidgetsCreate = (createInspirationWidget: NonReadonly<CreateInspirationWidget>, options?: SecondParameter<typeof customInstance>, signal?: AbortSignal) => {
    return customInstance<CreateInspirationWidget>(
        { url: `/api/v1/inspiration-widgets/`, method: "POST", headers: { "Content-Type": "application/json" }, data: createInspirationWidget, signal },
        options
    )
}

export const getInspirationWidgetsCreateMutationOptions = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof inspirationWidgetsCreate>>, TError, { data: NonReadonly<CreateInspirationWidget> }, TContext>
    request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<Awaited<ReturnType<typeof inspirationWidgetsCreate>>, TError, { data: NonReadonly<CreateInspirationWidget> }, TContext> => {
    const mutationKey = ["inspirationWidgetsCreate"]
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined }

    const mutationFn: MutationFunction<Awaited<ReturnType<typeof inspirationWidgetsCreate>>, { data: NonReadonly<CreateInspirationWidget> }> = (props) => {
        const { data } = props ?? {}

        return inspirationWidgetsCreate(data, requestOptions)
    }

    return { mutationFn, ...mutationOptions }
}

export type InspirationWidgetsCreateMutationResult = NonNullable<Awaited<ReturnType<typeof inspirationWidgetsCreate>>>
export type InspirationWidgetsCreateMutationBody = NonReadonly<CreateInspirationWidget>
export type InspirationWidgetsCreateMutationError = unknown

export const useInspirationWidgetsCreate = <TError = unknown, TContext = unknown>(
    options?: {
        mutation?: UseMutationOptions<Awaited<ReturnType<typeof inspirationWidgetsCreate>>, TError, { data: NonReadonly<CreateInspirationWidget> }, TContext>
        request?: SecondParameter<typeof customInstance>
    },
    queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof inspirationWidgetsCreate>>, TError, { data: NonReadonly<CreateInspirationWidget> }, TContext> => {
    const mutationOptions = getInspirationWidgetsCreateMutationOptions(options)

    return useMutation(mutationOptions, queryClient)
}

export const inspirationWidgetsRetrieve = (id: number, options?: SecondParameter<typeof customInstance>, signal?: AbortSignal) => {
    return customInstance<InspirationWidget>({ url: `/api/v1/inspiration-widgets/${id}/`, method: "GET", signal }, options)
}

export const getInspirationWidgetsRetrieveQueryKey = (id: number) => {
    return [`/api/v1/inspiration-widgets/${id}/`] as const
}

export const getInspirationWidgetsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof inspirationWidgetsRetrieve>>, TError = unknown>(
    id: number,
    options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof inspirationWidgetsRetrieve>>, TError, TData>>; request?: SecondParameter<typeof customInstance> }
) => {
    const { query: queryOptions, request: requestOptions } = options ?? {}

    const queryKey = queryOptions?.queryKey ?? getInspirationWidgetsRetrieveQueryKey(id)

    const queryFn: QueryFunction<Awaited<ReturnType<typeof inspirationWidgetsRetrieve>>> = ({ signal }) => inspirationWidgetsRetrieve(id, requestOptions, signal)

    return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<Awaited<ReturnType<typeof inspirationWidgetsRetrieve>>, TError, TData> & {
        queryKey: DataTag<QueryKey, TData, TError>
    }
}

export type InspirationWidgetsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof inspirationWidgetsRetrieve>>>
export type InspirationWidgetsRetrieveQueryError = unknown

export function useInspirationWidgetsRetrieve<TData = Awaited<ReturnType<typeof inspirationWidgetsRetrieve>>, TError = unknown>(
    id: number,
    options: {
        query: Partial<UseQueryOptions<Awaited<ReturnType<typeof inspirationWidgetsRetrieve>>, TError, TData>> &
            Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof inspirationWidgetsRetrieve>>, TError, Awaited<ReturnType<typeof inspirationWidgetsRetrieve>>>, "initialData">
        request?: SecondParameter<typeof customInstance>
    },
    queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useInspirationWidgetsRetrieve<TData = Awaited<ReturnType<typeof inspirationWidgetsRetrieve>>, TError = unknown>(
    id: number,
    options?: {
        query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof inspirationWidgetsRetrieve>>, TError, TData>> &
            Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof inspirationWidgetsRetrieve>>, TError, Awaited<ReturnType<typeof inspirationWidgetsRetrieve>>>, "initialData">
        request?: SecondParameter<typeof customInstance>
    },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useInspirationWidgetsRetrieve<TData = Awaited<ReturnType<typeof inspirationWidgetsRetrieve>>, TError = unknown>(
    id: number,
    options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof inspirationWidgetsRetrieve>>, TError, TData>>; request?: SecondParameter<typeof customInstance> },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useInspirationWidgetsRetrieve<TData = Awaited<ReturnType<typeof inspirationWidgetsRetrieve>>, TError = unknown>(
    id: number,
    options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof inspirationWidgetsRetrieve>>, TError, TData>>; request?: SecondParameter<typeof customInstance> },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
    const queryOptions = getInspirationWidgetsRetrieveQueryOptions(id, options)

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

    query.queryKey = queryOptions.queryKey

    return query
}

export const inspirationWidgetsUpdate = (id: number, inspirationWidget: NonReadonly<InspirationWidget>, options?: SecondParameter<typeof customInstance>) => {
    return customInstance<InspirationWidget>({ url: `/api/v1/inspiration-widgets/${id}/`, method: "PUT", headers: { "Content-Type": "application/json" }, data: inspirationWidget }, options)
}

export const getInspirationWidgetsUpdateMutationOptions = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof inspirationWidgetsUpdate>>, TError, { id: number; data: NonReadonly<InspirationWidget> }, TContext>
    request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<Awaited<ReturnType<typeof inspirationWidgetsUpdate>>, TError, { id: number; data: NonReadonly<InspirationWidget> }, TContext> => {
    const mutationKey = ["inspirationWidgetsUpdate"]
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined }

    const mutationFn: MutationFunction<Awaited<ReturnType<typeof inspirationWidgetsUpdate>>, { id: number; data: NonReadonly<InspirationWidget> }> = (props) => {
        const { id, data } = props ?? {}

        return inspirationWidgetsUpdate(id, data, requestOptions)
    }

    return { mutationFn, ...mutationOptions }
}

export type InspirationWidgetsUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof inspirationWidgetsUpdate>>>
export type InspirationWidgetsUpdateMutationBody = NonReadonly<InspirationWidget>
export type InspirationWidgetsUpdateMutationError = unknown

export const useInspirationWidgetsUpdate = <TError = unknown, TContext = unknown>(
    options?: {
        mutation?: UseMutationOptions<Awaited<ReturnType<typeof inspirationWidgetsUpdate>>, TError, { id: number; data: NonReadonly<InspirationWidget> }, TContext>
        request?: SecondParameter<typeof customInstance>
    },
    queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof inspirationWidgetsUpdate>>, TError, { id: number; data: NonReadonly<InspirationWidget> }, TContext> => {
    const mutationOptions = getInspirationWidgetsUpdateMutationOptions(options)

    return useMutation(mutationOptions, queryClient)
}

export const inspirationWidgetsPartialUpdate = (id: number, patchedInspirationWidget: NonReadonly<PatchedInspirationWidget>, options?: SecondParameter<typeof customInstance>) => {
    return customInstance<InspirationWidget>({ url: `/api/v1/inspiration-widgets/${id}/`, method: "PATCH", headers: { "Content-Type": "application/json" }, data: patchedInspirationWidget }, options)
}

export const getInspirationWidgetsPartialUpdateMutationOptions = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof inspirationWidgetsPartialUpdate>>, TError, { id: number; data: NonReadonly<PatchedInspirationWidget> }, TContext>
    request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<Awaited<ReturnType<typeof inspirationWidgetsPartialUpdate>>, TError, { id: number; data: NonReadonly<PatchedInspirationWidget> }, TContext> => {
    const mutationKey = ["inspirationWidgetsPartialUpdate"]
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined }

    const mutationFn: MutationFunction<Awaited<ReturnType<typeof inspirationWidgetsPartialUpdate>>, { id: number; data: NonReadonly<PatchedInspirationWidget> }> = (props) => {
        const { id, data } = props ?? {}

        return inspirationWidgetsPartialUpdate(id, data, requestOptions)
    }

    return { mutationFn, ...mutationOptions }
}

export type InspirationWidgetsPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof inspirationWidgetsPartialUpdate>>>
export type InspirationWidgetsPartialUpdateMutationBody = NonReadonly<PatchedInspirationWidget>
export type InspirationWidgetsPartialUpdateMutationError = unknown

export const useInspirationWidgetsPartialUpdate = <TError = unknown, TContext = unknown>(
    options?: {
        mutation?: UseMutationOptions<Awaited<ReturnType<typeof inspirationWidgetsPartialUpdate>>, TError, { id: number; data: NonReadonly<PatchedInspirationWidget> }, TContext>
        request?: SecondParameter<typeof customInstance>
    },
    queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof inspirationWidgetsPartialUpdate>>, TError, { id: number; data: NonReadonly<PatchedInspirationWidget> }, TContext> => {
    const mutationOptions = getInspirationWidgetsPartialUpdateMutationOptions(options)

    return useMutation(mutationOptions, queryClient)
}

export const inspirationWidgetsDestroy = (id: number, options?: SecondParameter<typeof customInstance>) => {
    return customInstance<void>({ url: `/api/v1/inspiration-widgets/${id}/`, method: "DELETE" }, options)
}

export const getInspirationWidgetsDestroyMutationOptions = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof inspirationWidgetsDestroy>>, TError, { id: number }, TContext>
    request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<Awaited<ReturnType<typeof inspirationWidgetsDestroy>>, TError, { id: number }, TContext> => {
    const mutationKey = ["inspirationWidgetsDestroy"]
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined }

    const mutationFn: MutationFunction<Awaited<ReturnType<typeof inspirationWidgetsDestroy>>, { id: number }> = (props) => {
        const { id } = props ?? {}

        return inspirationWidgetsDestroy(id, requestOptions)
    }

    return { mutationFn, ...mutationOptions }
}

export type InspirationWidgetsDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof inspirationWidgetsDestroy>>>

export type InspirationWidgetsDestroyMutationError = unknown

export const useInspirationWidgetsDestroy = <TError = unknown, TContext = unknown>(
    options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof inspirationWidgetsDestroy>>, TError, { id: number }, TContext>; request?: SecondParameter<typeof customInstance> },
    queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof inspirationWidgetsDestroy>>, TError, { id: number }, TContext> => {
    const mutationOptions = getInspirationWidgetsDestroyMutationOptions(options)

    return useMutation(mutationOptions, queryClient)
}

export const usersList = (params?: UsersListParams, options?: SecondParameter<typeof customInstance>, signal?: AbortSignal) => {
    return customInstance<PaginatedUserList>({ url: `/api/v1/users/`, method: "GET", params, signal }, options)
}

export const getUsersListQueryKey = (params?: UsersListParams) => {
    return [`/api/v1/users/`, ...(params ? [params] : [])] as const
}

export const getUsersListQueryOptions = <TData = Awaited<ReturnType<typeof usersList>>, TError = unknown>(
    params?: UsersListParams,
    options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof usersList>>, TError, TData>>; request?: SecondParameter<typeof customInstance> }
) => {
    const { query: queryOptions, request: requestOptions } = options ?? {}

    const queryKey = queryOptions?.queryKey ?? getUsersListQueryKey(params)

    const queryFn: QueryFunction<Awaited<ReturnType<typeof usersList>>> = ({ signal }) => usersList(params, requestOptions, signal)

    return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<Awaited<ReturnType<typeof usersList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type UsersListQueryResult = NonNullable<Awaited<ReturnType<typeof usersList>>>
export type UsersListQueryError = unknown

export function useUsersList<TData = Awaited<ReturnType<typeof usersList>>, TError = unknown>(
    params: undefined | UsersListParams,
    options: {
        query: Partial<UseQueryOptions<Awaited<ReturnType<typeof usersList>>, TError, TData>> &
            Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof usersList>>, TError, Awaited<ReturnType<typeof usersList>>>, "initialData">
        request?: SecondParameter<typeof customInstance>
    },
    queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUsersList<TData = Awaited<ReturnType<typeof usersList>>, TError = unknown>(
    params?: UsersListParams,
    options?: {
        query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof usersList>>, TError, TData>> &
            Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof usersList>>, TError, Awaited<ReturnType<typeof usersList>>>, "initialData">
        request?: SecondParameter<typeof customInstance>
    },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUsersList<TData = Awaited<ReturnType<typeof usersList>>, TError = unknown>(
    params?: UsersListParams,
    options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof usersList>>, TError, TData>>; request?: SecondParameter<typeof customInstance> },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useUsersList<TData = Awaited<ReturnType<typeof usersList>>, TError = unknown>(
    params?: UsersListParams,
    options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof usersList>>, TError, TData>>; request?: SecondParameter<typeof customInstance> },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
    const queryOptions = getUsersListQueryOptions(params, options)

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

    query.queryKey = queryOptions.queryKey

    return query
}

export const usersCreate = (user: NonReadonly<User>, options?: SecondParameter<typeof customInstance>, signal?: AbortSignal) => {
    return customInstance<User>({ url: `/api/v1/users/`, method: "POST", headers: { "Content-Type": "application/json" }, data: user, signal }, options)
}

export const getUsersCreateMutationOptions = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof usersCreate>>, TError, { data: NonReadonly<User> }, TContext>
    request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<Awaited<ReturnType<typeof usersCreate>>, TError, { data: NonReadonly<User> }, TContext> => {
    const mutationKey = ["usersCreate"]
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined }

    const mutationFn: MutationFunction<Awaited<ReturnType<typeof usersCreate>>, { data: NonReadonly<User> }> = (props) => {
        const { data } = props ?? {}

        return usersCreate(data, requestOptions)
    }

    return { mutationFn, ...mutationOptions }
}

export type UsersCreateMutationResult = NonNullable<Awaited<ReturnType<typeof usersCreate>>>
export type UsersCreateMutationBody = NonReadonly<User>
export type UsersCreateMutationError = unknown

export const useUsersCreate = <TError = unknown, TContext = unknown>(
    options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof usersCreate>>, TError, { data: NonReadonly<User> }, TContext>; request?: SecondParameter<typeof customInstance> },
    queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof usersCreate>>, TError, { data: NonReadonly<User> }, TContext> => {
    const mutationOptions = getUsersCreateMutationOptions(options)

    return useMutation(mutationOptions, queryClient)
}

export const usersRetrieve = (id: number, options?: SecondParameter<typeof customInstance>, signal?: AbortSignal) => {
    return customInstance<User>({ url: `/api/v1/users/${id}/`, method: "GET", signal }, options)
}

export const getUsersRetrieveQueryKey = (id: number) => {
    return [`/api/v1/users/${id}/`] as const
}

export const getUsersRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof usersRetrieve>>, TError = unknown>(
    id: number,
    options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof usersRetrieve>>, TError, TData>>; request?: SecondParameter<typeof customInstance> }
) => {
    const { query: queryOptions, request: requestOptions } = options ?? {}

    const queryKey = queryOptions?.queryKey ?? getUsersRetrieveQueryKey(id)

    const queryFn: QueryFunction<Awaited<ReturnType<typeof usersRetrieve>>> = ({ signal }) => usersRetrieve(id, requestOptions, signal)

    return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<Awaited<ReturnType<typeof usersRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type UsersRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof usersRetrieve>>>
export type UsersRetrieveQueryError = unknown

export function useUsersRetrieve<TData = Awaited<ReturnType<typeof usersRetrieve>>, TError = unknown>(
    id: number,
    options: {
        query: Partial<UseQueryOptions<Awaited<ReturnType<typeof usersRetrieve>>, TError, TData>> &
            Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof usersRetrieve>>, TError, Awaited<ReturnType<typeof usersRetrieve>>>, "initialData">
        request?: SecondParameter<typeof customInstance>
    },
    queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUsersRetrieve<TData = Awaited<ReturnType<typeof usersRetrieve>>, TError = unknown>(
    id: number,
    options?: {
        query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof usersRetrieve>>, TError, TData>> &
            Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof usersRetrieve>>, TError, Awaited<ReturnType<typeof usersRetrieve>>>, "initialData">
        request?: SecondParameter<typeof customInstance>
    },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUsersRetrieve<TData = Awaited<ReturnType<typeof usersRetrieve>>, TError = unknown>(
    id: number,
    options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof usersRetrieve>>, TError, TData>>; request?: SecondParameter<typeof customInstance> },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useUsersRetrieve<TData = Awaited<ReturnType<typeof usersRetrieve>>, TError = unknown>(
    id: number,
    options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof usersRetrieve>>, TError, TData>>; request?: SecondParameter<typeof customInstance> },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
    const queryOptions = getUsersRetrieveQueryOptions(id, options)

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

    query.queryKey = queryOptions.queryKey

    return query
}

export const usersUpdate = (id: number, user: NonReadonly<User>, options?: SecondParameter<typeof customInstance>) => {
    return customInstance<User>({ url: `/api/v1/users/${id}/`, method: "PUT", headers: { "Content-Type": "application/json" }, data: user }, options)
}

export const getUsersUpdateMutationOptions = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof usersUpdate>>, TError, { id: number; data: NonReadonly<User> }, TContext>
    request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<Awaited<ReturnType<typeof usersUpdate>>, TError, { id: number; data: NonReadonly<User> }, TContext> => {
    const mutationKey = ["usersUpdate"]
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined }

    const mutationFn: MutationFunction<Awaited<ReturnType<typeof usersUpdate>>, { id: number; data: NonReadonly<User> }> = (props) => {
        const { id, data } = props ?? {}

        return usersUpdate(id, data, requestOptions)
    }

    return { mutationFn, ...mutationOptions }
}

export type UsersUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof usersUpdate>>>
export type UsersUpdateMutationBody = NonReadonly<User>
export type UsersUpdateMutationError = unknown

export const useUsersUpdate = <TError = unknown, TContext = unknown>(
    options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof usersUpdate>>, TError, { id: number; data: NonReadonly<User> }, TContext>; request?: SecondParameter<typeof customInstance> },
    queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof usersUpdate>>, TError, { id: number; data: NonReadonly<User> }, TContext> => {
    const mutationOptions = getUsersUpdateMutationOptions(options)

    return useMutation(mutationOptions, queryClient)
}

export const usersPartialUpdate = (id: number, patchedUser: NonReadonly<PatchedUser>, options?: SecondParameter<typeof customInstance>) => {
    return customInstance<User>({ url: `/api/v1/users/${id}/`, method: "PATCH", headers: { "Content-Type": "application/json" }, data: patchedUser }, options)
}

export const getUsersPartialUpdateMutationOptions = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof usersPartialUpdate>>, TError, { id: number; data: NonReadonly<PatchedUser> }, TContext>
    request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<Awaited<ReturnType<typeof usersPartialUpdate>>, TError, { id: number; data: NonReadonly<PatchedUser> }, TContext> => {
    const mutationKey = ["usersPartialUpdate"]
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined }

    const mutationFn: MutationFunction<Awaited<ReturnType<typeof usersPartialUpdate>>, { id: number; data: NonReadonly<PatchedUser> }> = (props) => {
        const { id, data } = props ?? {}

        return usersPartialUpdate(id, data, requestOptions)
    }

    return { mutationFn, ...mutationOptions }
}

export type UsersPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof usersPartialUpdate>>>
export type UsersPartialUpdateMutationBody = NonReadonly<PatchedUser>
export type UsersPartialUpdateMutationError = unknown

export const useUsersPartialUpdate = <TError = unknown, TContext = unknown>(
    options?: {
        mutation?: UseMutationOptions<Awaited<ReturnType<typeof usersPartialUpdate>>, TError, { id: number; data: NonReadonly<PatchedUser> }, TContext>
        request?: SecondParameter<typeof customInstance>
    },
    queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof usersPartialUpdate>>, TError, { id: number; data: NonReadonly<PatchedUser> }, TContext> => {
    const mutationOptions = getUsersPartialUpdateMutationOptions(options)

    return useMutation(mutationOptions, queryClient)
}

export const usersDestroy = (id: number, options?: SecondParameter<typeof customInstance>) => {
    return customInstance<void>({ url: `/api/v1/users/${id}/`, method: "DELETE" }, options)
}

export const getUsersDestroyMutationOptions = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof usersDestroy>>, TError, { id: number }, TContext>
    request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<Awaited<ReturnType<typeof usersDestroy>>, TError, { id: number }, TContext> => {
    const mutationKey = ["usersDestroy"]
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined }

    const mutationFn: MutationFunction<Awaited<ReturnType<typeof usersDestroy>>, { id: number }> = (props) => {
        const { id } = props ?? {}

        return usersDestroy(id, requestOptions)
    }

    return { mutationFn, ...mutationOptions }
}

export type UsersDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof usersDestroy>>>

export type UsersDestroyMutationError = unknown

export const useUsersDestroy = <TError = unknown, TContext = unknown>(
    options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof usersDestroy>>, TError, { id: number }, TContext>; request?: SecondParameter<typeof customInstance> },
    queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof usersDestroy>>, TError, { id: number }, TContext> => {
    const mutationOptions = getUsersDestroyMutationOptions(options)

    return useMutation(mutationOptions, queryClient)
}

export const widgetsRetrieve = (options?: SecondParameter<typeof customInstance>, signal?: AbortSignal) => {
    return customInstance<WidgetsBatch>({ url: `/api/v1/widgets/`, method: "GET", signal }, options)
}

export const getWidgetsRetrieveQueryKey = () => {
    return [`/api/v1/widgets/`] as const
}

export const getWidgetsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof widgetsRetrieve>>, TError = unknown>(options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof widgetsRetrieve>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
}) => {
    const { query: queryOptions, request: requestOptions } = options ?? {}

    const queryKey = queryOptions?.queryKey ?? getWidgetsRetrieveQueryKey()

    const queryFn: QueryFunction<Awaited<ReturnType<typeof widgetsRetrieve>>> = ({ signal }) => widgetsRetrieve(requestOptions, signal)

    return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<Awaited<ReturnType<typeof widgetsRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type WidgetsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof widgetsRetrieve>>>
export type WidgetsRetrieveQueryError = unknown

export function useWidgetsRetrieve<TData = Awaited<ReturnType<typeof widgetsRetrieve>>, TError = unknown>(
    options: {
        query: Partial<UseQueryOptions<Awaited<ReturnType<typeof widgetsRetrieve>>, TError, TData>> &
            Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof widgetsRetrieve>>, TError, Awaited<ReturnType<typeof widgetsRetrieve>>>, "initialData">
        request?: SecondParameter<typeof customInstance>
    },
    queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useWidgetsRetrieve<TData = Awaited<ReturnType<typeof widgetsRetrieve>>, TError = unknown>(
    options?: {
        query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof widgetsRetrieve>>, TError, TData>> &
            Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof widgetsRetrieve>>, TError, Awaited<ReturnType<typeof widgetsRetrieve>>>, "initialData">
        request?: SecondParameter<typeof customInstance>
    },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useWidgetsRetrieve<TData = Awaited<ReturnType<typeof widgetsRetrieve>>, TError = unknown>(
    options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof widgetsRetrieve>>, TError, TData>>; request?: SecondParameter<typeof customInstance> },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useWidgetsRetrieve<TData = Awaited<ReturnType<typeof widgetsRetrieve>>, TError = unknown>(
    options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof widgetsRetrieve>>, TError, TData>>; request?: SecondParameter<typeof customInstance> },
    queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
    const queryOptions = getWidgetsRetrieveQueryOptions(options)

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

    query.queryKey = queryOptions.queryKey

    return query
}
