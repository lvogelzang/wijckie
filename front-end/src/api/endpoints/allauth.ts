/**
 * Generated by orval v7.10.0 üç∫
 * Do not edit manually.
 * django-allauth: Headless API
 * # Introduction

Welcome to the django-allauth API specification. This API is intended to be
consumed by two different kind of clients:

- Web applications running in a **browser** context. For example, a
  single-page React application, to which the end user can navigate using a web
  browser.

- Applications, **apps** for short, executing in non-browser contexts. For example,
  a mobile Android or iOS application.

The security considerations for these two usage types are different. In a
browser context, cookies play a role.  Without taking special precautions, your
web application may be vulnerable to Cross-Site Request Forgery attacks.  For
mobile applications, this does not apply.

The API can be used for both use cases. Differences in handling of security is
automatically adjusted for, based on the request path used to make the API call.
For example, signing up can either be done using the
`/_allauth/browser/v1/auth/signup` or the `/_allauth/app/v1/auth/signup`
endpoint. For the **browser** usage, session cookies and CSRF protection
applies. For the **app** usage, cookies play no role, instead, a session token
is used.  The paths of all endpoints are documented in the form of
`/_allauth/{client}/v1/auth/signup`. Depending on the client type (`{client}`),
there may be slight differences in request/response handling.  This is
documented where applicable.


# Scope

The following functionality is all in scope and handled as part of this API:

- Regular accounts:
  - Login
  - Signup
  - Password forgotten
  - Manage email (add, remove, verify, select a different primary)
  - Change password.
  - Verification of email addresses.
- Two-Factor Authentication:
  - Authentication using an authenticator code
  - (De)activate TOTP
  - (Re)generate recovery codes
  - "Trust this browser"
- Third-party providers:
  - Authenticate by performing a browser-level redirect (synchronous request).
  - Authenticate by means of a provider token.
  - Connect additional provider accounts.
  - Disconnect existing provider accounts.
  - Setting a password in case no password was set, yet.
  - Querying additional information before signing up.
- Session management:
  - Listing all sessions for a user.
  - Signing out of any of those sessions.


# Browser Usage

For web applications running in a browser, routing needs to be setup correctly
such that the sessions initiated at the backend are accessible in the frontend.

## Routing

When using the API in a browser context, regular Django sessions are used, along
with the usual session cookies. There are several options for setting up the
routing of your application.


###  Single Domain Routing

With single domain, path-based routing, both your frontend and backend are
served from the same domain, for example `https://app.org`. You will have to
make sure that some paths are served by the frontend, and others by the backend.


### Sub-domain Routing

With sub-domain based routing, the frontend and backend are served from
different domains.  However, as session cookies are used, these different
domains must share common main domain.

For example, you may use `app.project.org` for the frontend, which
interfaces with the backend over at `backend.project.org`.  In this
setup, Django will need to be configured with:

```
SESSION_COOKIE_DOMAIN = "project.org"
CSRF_COOKIE_DOMAIN = "project.org"
```

If your organization hosts unrelated applications, for example, a CMS for
marketing purposes, on the top level domain (`project.org`), it is not advisable
to set the session cookie domain to `project.org`, as those other applications
could get access to the session cookie. In that case, it is advised to use
`backend.app.project.org` for the backend, and set the session cookie domain to
`app.project.org`.


# App Usage

For app based usage, cookies play no role, yet, sessions are still used. When a
user walks through the authentication flow, a session is created.  Having an
authenticated session is proof that the user is allowed to further interact with
the backend. Unauthenticated sessions are also needed to remember state while
the user proceeds to go over the required steps necessary to authenticate.


## Session Tokens

Given that there is no cookie to point to the session, the header
`X-Session-Token` is used instead. The way of working is as follows:

- If you do not have a session token yet, do not send the `X-Session-Token` header.

- When making requests, session tokens can appear in the metadata
  (`meta.session_token`) of authentication related responses. If a session
  token appears, store it (overwriting any previous session token), and ensure
  to add the token to the `X-Session-Token` header of all subsequent requests.

- When receiving an authentication related response with status code 410
  (`Gone`), that is meant to indicate that the session is no longer valid.
  Remove the session token and start clean.


## Access Tokens

While session tokens are required to handle the authentication process,
depending on your requirements, a different type of token may be needed once
authenticated.

For example, your app likely needs access to other APIs as well. These APIs may
 even be implemented using different technologies, in which case having a
 stateless token, possibly a JWT encoding the user ID, might be a good fit.

In this API and its implementation no assumptions, and no (limiting) design
decisions are made in this regard. The token strategy of django-allauth is
pluggable, such that you can expose your own access token when the user
authenticates. As for as the API specification is concerned, the access token
will appear in the response of metadata (`meta.access_token`) of a successful
authentication request. How you can customize the token strategy can be found
over at the documentation of the `allauth.headless` Django application.


# Responses

Unless documented otherwise, responses are objects with the following
properties:
- The `status`, matching the HTTP status code.
- Data, if any, is returned as part of the `data` key.
- Metadata, if any, is returned as part of the `meta` key.
- Errors, if any, are listed in the `errors` key.


# Authentication Flows

In order to become authenticated, the user must complete a flow, potentially
consisting of several steps. For example:
- A login, after which the user is authenticated.
- A Login, followed by two-factor authentication, after which the user is
  authenticated.
- A signup, followed by mandatory email verification, after which the user is
  authenticated.

The API signals to the client that (re)authentication is required by means of a
`401` or `410` status code:
- Not authenticated: status `401`.
- Re-authentication required: status `401`, with `meta.is_authenticated = true`.
- Invalid session: status `410`. This only occurs for clients of type `app`.

All authentication related responses have status `401` or `410`, and,
`meta.is_authenticated` indicating whether authentication, or re-authentication
is required.

The flows the client can perform to initiate or complete the authentication are
communicates as part of authentication related responses. The authentication can
be initiated by means of these flows:
- Login using a local account (`login`).
- Signup for a local account (`signup`).
- Login or signup using the third-party provider redirect flow (`provider_redirect`).
- Login or signup by handing over a third-party provider retrieved elsewhere (`provider_token`).
- Login using a special code (`login_by_code`).
- Login using a passkey (`mfa_login_webauthn`).
- Signup using a passkey (`mfa_signup_webauthn`).

Depending on the state of the account, and the configuration of django-allauth, the flows above
can either lead to becoming directly authenticated, or, to followup flows:
- Provider signup (`provider_signup`).
- Email verification (`verify_email`).
- Phone verification (`phone_email`).
- Two-factor authentication required (TOTP, recovery codes, or WebAuthn) (`mfa_authenticate`).
- Trust this browser (`mfa_trust`).

While authenticated, re-authentication may be required to safeguard the account when sensitive actions
are performed. The re-authentication flows are the following:
- Re-authenticate using password (`reauthenticate`).
- Re-authenticate using a 2FA authenticator (TOTP, recovery codes, or WebAuthn) (`mfa_reauthenticate`).


# Security Considerations

## Input Sanitization

The Django framework, by design, does *not* perform input sanitization. For
example, there is nothing preventing end users from signing up using `<script>`
or `Robert'); DROP TABLE students` as a first name. Django relies on its
template language for proper escaping of such values and mitigate any XSS
attacks.

As a result, any `allauth.headless` client **must** have proper XSS protection
in place as well. Be prepared that, for example, the WebAuthn endpoints could
return authenticator names as follows:

    {
      "name": "<script>alert(1)</script>",
      "credential": {
        "type": "public-key",
        ...
      }
    }
 * OpenAPI spec version: 1
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  AddAuthenticatorConflictResponse,
  AddWebAuthnAuthenticatorBody,
  AddWebAuthnAuthenticatorResponse,
  AuthenticateWebAuthnBody,
  AuthenticatedByCodeResponse,
  AuthenticatedByPasswordAnd2FAResponse,
  AuthenticatedByPasswordResponse,
  AuthenticatedResponse,
  AuthenticationOrReauthenticationResponse,
  AuthenticationResponse,
  AuthenticatorsResponse,
  ChangePasswordBody,
  ConfigurationResponse,
  ConfirmLoginCodeBody,
  ConflictResponse,
  DeleteWebAuthnBody,
  EmailAddressesResponse,
  EmailBody,
  EmailVerificationInfoResponse,
  ErrorResponse,
  ForbiddenResponse,
  LoginBody,
  LoginWebAuthnBody,
  MFAAuthenticateBody,
  MarkPrimaryEmailBody,
  NotFoundResponse,
  PasskeySignupBody,
  PasswordResetInfoResponse,
  PhoneBody,
  PhoneNumberChangeResponse,
  PhoneNumbersResponse,
  ReauthenticateBody,
  ReauthenticateWebAuthnBody,
  ReauthenticationRequiredResponse,
  RecoveryCodesResponse,
  RequestLoginCodeBody,
  RequestPasswordBody,
  ResetPasswordBody,
  SessionGoneResponse,
  SetupTOTPBody,
  SignupBody,
  StatusOKResponse,
  TOTPAuthenticatorNotFoundResponse,
  TOTPAuthenticatorResponse,
  TooManyRequestsResponse,
  UnauthenticatedResponse,
  UpdateWebAuthnBody,
  VerifyEmailBody,
  VerifyPhoneBody,
  WebAuthnAuthenticatorResponse,
  WebAuthnCreationOptionsResponseResponse,
  WebAuthnRequestOptionsResponseResponse
} from '../models/allauth';

import { customInstance } from '../../helpers/api';


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * @summary List authenticators
 */
export const getAllauthClientV1AccountAuthenticators = (
    client: 'app' | 'browser',
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<AuthenticatorsResponse>(
      {url: `/_allauth/${client}/v1/account/authenticators`, method: 'GET', signal
    },
      options);
    }
  

export const getGetAllauthClientV1AccountAuthenticatorsQueryKey = (client: 'app' | 'browser',) => {
    return [`/_allauth/${client}/v1/account/authenticators`] as const;
    }

    
export const getGetAllauthClientV1AccountAuthenticatorsQueryOptions = <TData = Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticators>>, TError = AuthenticationResponse | SessionGoneResponse>(client: 'app' | 'browser', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticators>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllauthClientV1AccountAuthenticatorsQueryKey(client);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticators>>> = ({ signal }) => getAllauthClientV1AccountAuthenticators(client, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(client), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticators>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllauthClientV1AccountAuthenticatorsQueryResult = NonNullable<Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticators>>>
export type GetAllauthClientV1AccountAuthenticatorsQueryError = AuthenticationResponse | SessionGoneResponse


export function useGetAllauthClientV1AccountAuthenticators<TData = Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticators>>, TError = AuthenticationResponse | SessionGoneResponse>(
 client: 'app' | 'browser', options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticators>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticators>>,
          TError,
          Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticators>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllauthClientV1AccountAuthenticators<TData = Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticators>>, TError = AuthenticationResponse | SessionGoneResponse>(
 client: 'app' | 'browser', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticators>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticators>>,
          TError,
          Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticators>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllauthClientV1AccountAuthenticators<TData = Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticators>>, TError = AuthenticationResponse | SessionGoneResponse>(
 client: 'app' | 'browser', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticators>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List authenticators
 */

export function useGetAllauthClientV1AccountAuthenticators<TData = Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticators>>, TError = AuthenticationResponse | SessionGoneResponse>(
 client: 'app' | 'browser', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticators>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllauthClientV1AccountAuthenticatorsQueryOptions(client,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * List recovery codes.

 * @summary List recovery codes
 */
export const getAllauthClientV1AccountAuthenticatorsRecoveryCodes = (
    client: 'app' | 'browser',
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<RecoveryCodesResponse>(
      {url: `/_allauth/${client}/v1/account/authenticators/recovery-codes`, method: 'GET', signal
    },
      options);
    }
  

export const getGetAllauthClientV1AccountAuthenticatorsRecoveryCodesQueryKey = (client: 'app' | 'browser',) => {
    return [`/_allauth/${client}/v1/account/authenticators/recovery-codes`] as const;
    }

    
export const getGetAllauthClientV1AccountAuthenticatorsRecoveryCodesQueryOptions = <TData = Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsRecoveryCodes>>, TError = ReauthenticationRequiredResponse | NotFoundResponse>(client: 'app' | 'browser', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsRecoveryCodes>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllauthClientV1AccountAuthenticatorsRecoveryCodesQueryKey(client);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsRecoveryCodes>>> = ({ signal }) => getAllauthClientV1AccountAuthenticatorsRecoveryCodes(client, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(client), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsRecoveryCodes>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllauthClientV1AccountAuthenticatorsRecoveryCodesQueryResult = NonNullable<Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsRecoveryCodes>>>
export type GetAllauthClientV1AccountAuthenticatorsRecoveryCodesQueryError = ReauthenticationRequiredResponse | NotFoundResponse


export function useGetAllauthClientV1AccountAuthenticatorsRecoveryCodes<TData = Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsRecoveryCodes>>, TError = ReauthenticationRequiredResponse | NotFoundResponse>(
 client: 'app' | 'browser', options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsRecoveryCodes>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsRecoveryCodes>>,
          TError,
          Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsRecoveryCodes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllauthClientV1AccountAuthenticatorsRecoveryCodes<TData = Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsRecoveryCodes>>, TError = ReauthenticationRequiredResponse | NotFoundResponse>(
 client: 'app' | 'browser', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsRecoveryCodes>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsRecoveryCodes>>,
          TError,
          Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsRecoveryCodes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllauthClientV1AccountAuthenticatorsRecoveryCodes<TData = Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsRecoveryCodes>>, TError = ReauthenticationRequiredResponse | NotFoundResponse>(
 client: 'app' | 'browser', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsRecoveryCodes>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List recovery codes
 */

export function useGetAllauthClientV1AccountAuthenticatorsRecoveryCodes<TData = Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsRecoveryCodes>>, TError = ReauthenticationRequiredResponse | NotFoundResponse>(
 client: 'app' | 'browser', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsRecoveryCodes>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllauthClientV1AccountAuthenticatorsRecoveryCodesQueryOptions(client,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Regenerate recovery codes
 */
export const postAllauthClientV1AccountAuthenticatorsRecoveryCodes = (
    client: 'app' | 'browser',
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/_allauth/${client}/v1/account/authenticators/recovery-codes`, method: 'POST', signal
    },
      options);
    }
  


export const getPostAllauthClientV1AccountAuthenticatorsRecoveryCodesMutationOptions = <TError = ErrorResponse | ReauthenticationRequiredResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AccountAuthenticatorsRecoveryCodes>>, TError,{client: 'app' | 'browser'}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AccountAuthenticatorsRecoveryCodes>>, TError,{client: 'app' | 'browser'}, TContext> => {

const mutationKey = ['postAllauthClientV1AccountAuthenticatorsRecoveryCodes'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postAllauthClientV1AccountAuthenticatorsRecoveryCodes>>, {client: 'app' | 'browser'}> = (props) => {
          const {client} = props ?? {};

          return  postAllauthClientV1AccountAuthenticatorsRecoveryCodes(client,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostAllauthClientV1AccountAuthenticatorsRecoveryCodesMutationResult = NonNullable<Awaited<ReturnType<typeof postAllauthClientV1AccountAuthenticatorsRecoveryCodes>>>
    
    export type PostAllauthClientV1AccountAuthenticatorsRecoveryCodesMutationError = ErrorResponse | ReauthenticationRequiredResponse

    /**
 * @summary Regenerate recovery codes
 */
export const usePostAllauthClientV1AccountAuthenticatorsRecoveryCodes = <TError = ErrorResponse | ReauthenticationRequiredResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AccountAuthenticatorsRecoveryCodes>>, TError,{client: 'app' | 'browser'}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postAllauthClientV1AccountAuthenticatorsRecoveryCodes>>,
        TError,
        {client: 'app' | 'browser'},
        TContext
      > => {

      const mutationOptions = getPostAllauthClientV1AccountAuthenticatorsRecoveryCodesMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Deactivates TOTP authentication. If the user authentication is not
sufficiently recent, a reauthentication flow (`401`) will is presented.

 * @summary Deactivate TOTP
 */
export const deleteAllauthClientV1AccountAuthenticatorsTotp = (
    client: 'app' | 'browser',
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<StatusOKResponse>(
      {url: `/_allauth/${client}/v1/account/authenticators/totp`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteAllauthClientV1AccountAuthenticatorsTotpMutationOptions = <TError = ReauthenticationRequiredResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAllauthClientV1AccountAuthenticatorsTotp>>, TError,{client: 'app' | 'browser'}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteAllauthClientV1AccountAuthenticatorsTotp>>, TError,{client: 'app' | 'browser'}, TContext> => {

const mutationKey = ['deleteAllauthClientV1AccountAuthenticatorsTotp'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteAllauthClientV1AccountAuthenticatorsTotp>>, {client: 'app' | 'browser'}> = (props) => {
          const {client} = props ?? {};

          return  deleteAllauthClientV1AccountAuthenticatorsTotp(client,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteAllauthClientV1AccountAuthenticatorsTotpMutationResult = NonNullable<Awaited<ReturnType<typeof deleteAllauthClientV1AccountAuthenticatorsTotp>>>
    
    export type DeleteAllauthClientV1AccountAuthenticatorsTotpMutationError = ReauthenticationRequiredResponse

    /**
 * @summary Deactivate TOTP
 */
export const useDeleteAllauthClientV1AccountAuthenticatorsTotp = <TError = ReauthenticationRequiredResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAllauthClientV1AccountAuthenticatorsTotp>>, TError,{client: 'app' | 'browser'}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteAllauthClientV1AccountAuthenticatorsTotp>>,
        TError,
        {client: 'app' | 'browser'},
        TContext
      > => {

      const mutationOptions = getDeleteAllauthClientV1AccountAuthenticatorsTotpMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve the information about the current TOTP authenticator, if any.

 * @summary TOTP authenticator status
 */
export const getAllauthClientV1AccountAuthenticatorsTotp = (
    client: 'app' | 'browser',
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<TOTPAuthenticatorResponse>(
      {url: `/_allauth/${client}/v1/account/authenticators/totp`, method: 'GET', signal
    },
      options);
    }
  

export const getGetAllauthClientV1AccountAuthenticatorsTotpQueryKey = (client: 'app' | 'browser',) => {
    return [`/_allauth/${client}/v1/account/authenticators/totp`] as const;
    }

    
export const getGetAllauthClientV1AccountAuthenticatorsTotpQueryOptions = <TData = Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsTotp>>, TError = TOTPAuthenticatorNotFoundResponse | AddAuthenticatorConflictResponse>(client: 'app' | 'browser', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsTotp>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllauthClientV1AccountAuthenticatorsTotpQueryKey(client);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsTotp>>> = ({ signal }) => getAllauthClientV1AccountAuthenticatorsTotp(client, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(client), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsTotp>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllauthClientV1AccountAuthenticatorsTotpQueryResult = NonNullable<Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsTotp>>>
export type GetAllauthClientV1AccountAuthenticatorsTotpQueryError = TOTPAuthenticatorNotFoundResponse | AddAuthenticatorConflictResponse


export function useGetAllauthClientV1AccountAuthenticatorsTotp<TData = Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsTotp>>, TError = TOTPAuthenticatorNotFoundResponse | AddAuthenticatorConflictResponse>(
 client: 'app' | 'browser', options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsTotp>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsTotp>>,
          TError,
          Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsTotp>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllauthClientV1AccountAuthenticatorsTotp<TData = Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsTotp>>, TError = TOTPAuthenticatorNotFoundResponse | AddAuthenticatorConflictResponse>(
 client: 'app' | 'browser', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsTotp>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsTotp>>,
          TError,
          Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsTotp>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllauthClientV1AccountAuthenticatorsTotp<TData = Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsTotp>>, TError = TOTPAuthenticatorNotFoundResponse | AddAuthenticatorConflictResponse>(
 client: 'app' | 'browser', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsTotp>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary TOTP authenticator status
 */

export function useGetAllauthClientV1AccountAuthenticatorsTotp<TData = Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsTotp>>, TError = TOTPAuthenticatorNotFoundResponse | AddAuthenticatorConflictResponse>(
 client: 'app' | 'browser', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsTotp>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllauthClientV1AccountAuthenticatorsTotpQueryOptions(client,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * The code should be provided from the consuming TOTP authenticator
application which was generated using the TOTP authenticator secret
retrieved from the TOTP authenticator status endpoint.

 * @summary Activate TOTP
 */
export const postAllauthClientV1AccountAuthenticatorsTotp = (
    client: 'app' | 'browser',
    setupTOTPBody: SetupTOTPBody,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<TOTPAuthenticatorResponse>(
      {url: `/_allauth/${client}/v1/account/authenticators/totp`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: setupTOTPBody, signal
    },
      options);
    }
  


export const getPostAllauthClientV1AccountAuthenticatorsTotpMutationOptions = <TError = ErrorResponse | AddAuthenticatorConflictResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AccountAuthenticatorsTotp>>, TError,{client: 'app' | 'browser';data: SetupTOTPBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AccountAuthenticatorsTotp>>, TError,{client: 'app' | 'browser';data: SetupTOTPBody}, TContext> => {

const mutationKey = ['postAllauthClientV1AccountAuthenticatorsTotp'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postAllauthClientV1AccountAuthenticatorsTotp>>, {client: 'app' | 'browser';data: SetupTOTPBody}> = (props) => {
          const {client,data} = props ?? {};

          return  postAllauthClientV1AccountAuthenticatorsTotp(client,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostAllauthClientV1AccountAuthenticatorsTotpMutationResult = NonNullable<Awaited<ReturnType<typeof postAllauthClientV1AccountAuthenticatorsTotp>>>
    export type PostAllauthClientV1AccountAuthenticatorsTotpMutationBody = SetupTOTPBody
    export type PostAllauthClientV1AccountAuthenticatorsTotpMutationError = ErrorResponse | AddAuthenticatorConflictResponse

    /**
 * @summary Activate TOTP
 */
export const usePostAllauthClientV1AccountAuthenticatorsTotp = <TError = ErrorResponse | AddAuthenticatorConflictResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AccountAuthenticatorsTotp>>, TError,{client: 'app' | 'browser';data: SetupTOTPBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postAllauthClientV1AccountAuthenticatorsTotp>>,
        TError,
        {client: 'app' | 'browser';data: SetupTOTPBody},
        TContext
      > => {

      const mutationOptions = getPostAllauthClientV1AccountAuthenticatorsTotpMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Delete a WebAuthn credential

 */
export const deleteAllauthClientV1AccountAuthenticatorsWebauthn = (
    client: 'app' | 'browser',
    deleteWebAuthnBody: DeleteWebAuthnBody,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<StatusOKResponse>(
      {url: `/_allauth/${client}/v1/account/authenticators/webauthn`, method: 'DELETE',
      headers: {'Content-Type': 'application/json', },
      data: deleteWebAuthnBody
    },
      options);
    }
  


export const getDeleteAllauthClientV1AccountAuthenticatorsWebauthnMutationOptions = <TError = ReauthenticationRequiredResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAllauthClientV1AccountAuthenticatorsWebauthn>>, TError,{client: 'app' | 'browser';data: DeleteWebAuthnBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteAllauthClientV1AccountAuthenticatorsWebauthn>>, TError,{client: 'app' | 'browser';data: DeleteWebAuthnBody}, TContext> => {

const mutationKey = ['deleteAllauthClientV1AccountAuthenticatorsWebauthn'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteAllauthClientV1AccountAuthenticatorsWebauthn>>, {client: 'app' | 'browser';data: DeleteWebAuthnBody}> = (props) => {
          const {client,data} = props ?? {};

          return  deleteAllauthClientV1AccountAuthenticatorsWebauthn(client,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteAllauthClientV1AccountAuthenticatorsWebauthnMutationResult = NonNullable<Awaited<ReturnType<typeof deleteAllauthClientV1AccountAuthenticatorsWebauthn>>>
    export type DeleteAllauthClientV1AccountAuthenticatorsWebauthnMutationBody = DeleteWebAuthnBody
    export type DeleteAllauthClientV1AccountAuthenticatorsWebauthnMutationError = ReauthenticationRequiredResponse

    /**
 * @summary Delete a WebAuthn credential

 */
export const useDeleteAllauthClientV1AccountAuthenticatorsWebauthn = <TError = ReauthenticationRequiredResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAllauthClientV1AccountAuthenticatorsWebauthn>>, TError,{client: 'app' | 'browser';data: DeleteWebAuthnBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteAllauthClientV1AccountAuthenticatorsWebauthn>>,
        TError,
        {client: 'app' | 'browser';data: DeleteWebAuthnBody},
        TContext
      > => {

      const mutationOptions = getDeleteAllauthClientV1AccountAuthenticatorsWebauthnMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Returns the WebAuthn credential creation options, that can be
processed using `parseCreationOptionsFromJSON()` on the frontend.

 * @summary Get WebAuthn credential creation options

 */
export const getAllauthClientV1AccountAuthenticatorsWebauthn = (
    client: 'app' | 'browser',
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<WebAuthnCreationOptionsResponseResponse>(
      {url: `/_allauth/${client}/v1/account/authenticators/webauthn`, method: 'GET', signal
    },
      options);
    }
  

export const getGetAllauthClientV1AccountAuthenticatorsWebauthnQueryKey = (client: 'app' | 'browser',) => {
    return [`/_allauth/${client}/v1/account/authenticators/webauthn`] as const;
    }

    
export const getGetAllauthClientV1AccountAuthenticatorsWebauthnQueryOptions = <TData = Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsWebauthn>>, TError = ReauthenticationRequiredResponse | AddAuthenticatorConflictResponse>(client: 'app' | 'browser', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsWebauthn>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllauthClientV1AccountAuthenticatorsWebauthnQueryKey(client);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsWebauthn>>> = ({ signal }) => getAllauthClientV1AccountAuthenticatorsWebauthn(client, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(client), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsWebauthn>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllauthClientV1AccountAuthenticatorsWebauthnQueryResult = NonNullable<Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsWebauthn>>>
export type GetAllauthClientV1AccountAuthenticatorsWebauthnQueryError = ReauthenticationRequiredResponse | AddAuthenticatorConflictResponse


export function useGetAllauthClientV1AccountAuthenticatorsWebauthn<TData = Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsWebauthn>>, TError = ReauthenticationRequiredResponse | AddAuthenticatorConflictResponse>(
 client: 'app' | 'browser', options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsWebauthn>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsWebauthn>>,
          TError,
          Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsWebauthn>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllauthClientV1AccountAuthenticatorsWebauthn<TData = Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsWebauthn>>, TError = ReauthenticationRequiredResponse | AddAuthenticatorConflictResponse>(
 client: 'app' | 'browser', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsWebauthn>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsWebauthn>>,
          TError,
          Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsWebauthn>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllauthClientV1AccountAuthenticatorsWebauthn<TData = Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsWebauthn>>, TError = ReauthenticationRequiredResponse | AddAuthenticatorConflictResponse>(
 client: 'app' | 'browser', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsWebauthn>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get WebAuthn credential creation options

 */

export function useGetAllauthClientV1AccountAuthenticatorsWebauthn<TData = Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsWebauthn>>, TError = ReauthenticationRequiredResponse | AddAuthenticatorConflictResponse>(
 client: 'app' | 'browser', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsWebauthn>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllauthClientV1AccountAuthenticatorsWebauthnQueryOptions(client,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Add a WebAuthn credential

 */
export const postAllauthClientV1AccountAuthenticatorsWebauthn = (
    client: 'app' | 'browser',
    addWebAuthnAuthenticatorBody: AddWebAuthnAuthenticatorBody,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<AddWebAuthnAuthenticatorResponse>(
      {url: `/_allauth/${client}/v1/account/authenticators/webauthn`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: addWebAuthnAuthenticatorBody, signal
    },
      options);
    }
  


export const getPostAllauthClientV1AccountAuthenticatorsWebauthnMutationOptions = <TError = ReauthenticationRequiredResponse | AddAuthenticatorConflictResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AccountAuthenticatorsWebauthn>>, TError,{client: 'app' | 'browser';data: AddWebAuthnAuthenticatorBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AccountAuthenticatorsWebauthn>>, TError,{client: 'app' | 'browser';data: AddWebAuthnAuthenticatorBody}, TContext> => {

const mutationKey = ['postAllauthClientV1AccountAuthenticatorsWebauthn'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postAllauthClientV1AccountAuthenticatorsWebauthn>>, {client: 'app' | 'browser';data: AddWebAuthnAuthenticatorBody}> = (props) => {
          const {client,data} = props ?? {};

          return  postAllauthClientV1AccountAuthenticatorsWebauthn(client,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostAllauthClientV1AccountAuthenticatorsWebauthnMutationResult = NonNullable<Awaited<ReturnType<typeof postAllauthClientV1AccountAuthenticatorsWebauthn>>>
    export type PostAllauthClientV1AccountAuthenticatorsWebauthnMutationBody = AddWebAuthnAuthenticatorBody
    export type PostAllauthClientV1AccountAuthenticatorsWebauthnMutationError = ReauthenticationRequiredResponse | AddAuthenticatorConflictResponse

    /**
 * @summary Add a WebAuthn credential

 */
export const usePostAllauthClientV1AccountAuthenticatorsWebauthn = <TError = ReauthenticationRequiredResponse | AddAuthenticatorConflictResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AccountAuthenticatorsWebauthn>>, TError,{client: 'app' | 'browser';data: AddWebAuthnAuthenticatorBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postAllauthClientV1AccountAuthenticatorsWebauthn>>,
        TError,
        {client: 'app' | 'browser';data: AddWebAuthnAuthenticatorBody},
        TContext
      > => {

      const mutationOptions = getPostAllauthClientV1AccountAuthenticatorsWebauthnMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * You can alter the name of a WebAuthn credential by PUT'ting the ID and
name of the authenticator representing that credential. You can obtain
the credentials via the "List authenticators" endpoint.

 * @summary Rename a WebAuthn credential

 */
export const putAllauthClientV1AccountAuthenticatorsWebauthn = (
    client: 'app' | 'browser',
    updateWebAuthnBody: UpdateWebAuthnBody,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<WebAuthnAuthenticatorResponse>(
      {url: `/_allauth/${client}/v1/account/authenticators/webauthn`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: updateWebAuthnBody
    },
      options);
    }
  


export const getPutAllauthClientV1AccountAuthenticatorsWebauthnMutationOptions = <TError = ReauthenticationRequiredResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putAllauthClientV1AccountAuthenticatorsWebauthn>>, TError,{client: 'app' | 'browser';data: UpdateWebAuthnBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof putAllauthClientV1AccountAuthenticatorsWebauthn>>, TError,{client: 'app' | 'browser';data: UpdateWebAuthnBody}, TContext> => {

const mutationKey = ['putAllauthClientV1AccountAuthenticatorsWebauthn'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putAllauthClientV1AccountAuthenticatorsWebauthn>>, {client: 'app' | 'browser';data: UpdateWebAuthnBody}> = (props) => {
          const {client,data} = props ?? {};

          return  putAllauthClientV1AccountAuthenticatorsWebauthn(client,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutAllauthClientV1AccountAuthenticatorsWebauthnMutationResult = NonNullable<Awaited<ReturnType<typeof putAllauthClientV1AccountAuthenticatorsWebauthn>>>
    export type PutAllauthClientV1AccountAuthenticatorsWebauthnMutationBody = UpdateWebAuthnBody
    export type PutAllauthClientV1AccountAuthenticatorsWebauthnMutationError = ReauthenticationRequiredResponse

    /**
 * @summary Rename a WebAuthn credential

 */
export const usePutAllauthClientV1AccountAuthenticatorsWebauthn = <TError = ReauthenticationRequiredResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putAllauthClientV1AccountAuthenticatorsWebauthn>>, TError,{client: 'app' | 'browser';data: UpdateWebAuthnBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof putAllauthClientV1AccountAuthenticatorsWebauthn>>,
        TError,
        {client: 'app' | 'browser';data: UpdateWebAuthnBody},
        TContext
      > => {

      const mutationOptions = getPutAllauthClientV1AccountAuthenticatorsWebauthnMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Used to remove an email address.

 * @summary Remove an email address
 */
export const deleteAllauthClientV1AccountEmail = (
    client: 'app' | 'browser',
    emailBody: EmailBody,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<EmailAddressesResponse>(
      {url: `/_allauth/${client}/v1/account/email`, method: 'DELETE',
      headers: {'Content-Type': 'application/json', },
      data: emailBody
    },
      options);
    }
  


export const getDeleteAllauthClientV1AccountEmailMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAllauthClientV1AccountEmail>>, TError,{client: 'app' | 'browser';data: EmailBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteAllauthClientV1AccountEmail>>, TError,{client: 'app' | 'browser';data: EmailBody}, TContext> => {

const mutationKey = ['deleteAllauthClientV1AccountEmail'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteAllauthClientV1AccountEmail>>, {client: 'app' | 'browser';data: EmailBody}> = (props) => {
          const {client,data} = props ?? {};

          return  deleteAllauthClientV1AccountEmail(client,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteAllauthClientV1AccountEmailMutationResult = NonNullable<Awaited<ReturnType<typeof deleteAllauthClientV1AccountEmail>>>
    export type DeleteAllauthClientV1AccountEmailMutationBody = EmailBody
    export type DeleteAllauthClientV1AccountEmailMutationError = ErrorResponse

    /**
 * @summary Remove an email address
 */
export const useDeleteAllauthClientV1AccountEmail = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAllauthClientV1AccountEmail>>, TError,{client: 'app' | 'browser';data: EmailBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteAllauthClientV1AccountEmail>>,
        TError,
        {client: 'app' | 'browser';data: EmailBody},
        TContext
      > => {

      const mutationOptions = getDeleteAllauthClientV1AccountEmailMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieves the list of email addreses of the account.

 * @summary List email addresses
 */
export const getAllauthClientV1AccountEmail = (
    client: 'app' | 'browser',
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<EmailAddressesResponse>(
      {url: `/_allauth/${client}/v1/account/email`, method: 'GET', signal
    },
      options);
    }
  

export const getGetAllauthClientV1AccountEmailQueryKey = (client: 'app' | 'browser',) => {
    return [`/_allauth/${client}/v1/account/email`] as const;
    }

    
export const getGetAllauthClientV1AccountEmailQueryOptions = <TData = Awaited<ReturnType<typeof getAllauthClientV1AccountEmail>>, TError = AuthenticationResponse>(client: 'app' | 'browser', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AccountEmail>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllauthClientV1AccountEmailQueryKey(client);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllauthClientV1AccountEmail>>> = ({ signal }) => getAllauthClientV1AccountEmail(client, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(client), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AccountEmail>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllauthClientV1AccountEmailQueryResult = NonNullable<Awaited<ReturnType<typeof getAllauthClientV1AccountEmail>>>
export type GetAllauthClientV1AccountEmailQueryError = AuthenticationResponse


export function useGetAllauthClientV1AccountEmail<TData = Awaited<ReturnType<typeof getAllauthClientV1AccountEmail>>, TError = AuthenticationResponse>(
 client: 'app' | 'browser', options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AccountEmail>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllauthClientV1AccountEmail>>,
          TError,
          Awaited<ReturnType<typeof getAllauthClientV1AccountEmail>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllauthClientV1AccountEmail<TData = Awaited<ReturnType<typeof getAllauthClientV1AccountEmail>>, TError = AuthenticationResponse>(
 client: 'app' | 'browser', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AccountEmail>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllauthClientV1AccountEmail>>,
          TError,
          Awaited<ReturnType<typeof getAllauthClientV1AccountEmail>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllauthClientV1AccountEmail<TData = Awaited<ReturnType<typeof getAllauthClientV1AccountEmail>>, TError = AuthenticationResponse>(
 client: 'app' | 'browser', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AccountEmail>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List email addresses
 */

export function useGetAllauthClientV1AccountEmail<TData = Awaited<ReturnType<typeof getAllauthClientV1AccountEmail>>, TError = AuthenticationResponse>(
 client: 'app' | 'browser', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AccountEmail>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllauthClientV1AccountEmailQueryOptions(client,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Used to change primary email address to a different one. Note that only verified email addresses
can be marked as primary.

 * @summary Change primary email address
 */
export const patchAllauthClientV1AccountEmail = (
    client: 'app' | 'browser',
    markPrimaryEmailBody: MarkPrimaryEmailBody,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<EmailAddressesResponse>(
      {url: `/_allauth/${client}/v1/account/email`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: markPrimaryEmailBody
    },
      options);
    }
  


export const getPatchAllauthClientV1AccountEmailMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchAllauthClientV1AccountEmail>>, TError,{client: 'app' | 'browser';data: MarkPrimaryEmailBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof patchAllauthClientV1AccountEmail>>, TError,{client: 'app' | 'browser';data: MarkPrimaryEmailBody}, TContext> => {

const mutationKey = ['patchAllauthClientV1AccountEmail'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchAllauthClientV1AccountEmail>>, {client: 'app' | 'browser';data: MarkPrimaryEmailBody}> = (props) => {
          const {client,data} = props ?? {};

          return  patchAllauthClientV1AccountEmail(client,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatchAllauthClientV1AccountEmailMutationResult = NonNullable<Awaited<ReturnType<typeof patchAllauthClientV1AccountEmail>>>
    export type PatchAllauthClientV1AccountEmailMutationBody = MarkPrimaryEmailBody
    export type PatchAllauthClientV1AccountEmailMutationError = ErrorResponse

    /**
 * @summary Change primary email address
 */
export const usePatchAllauthClientV1AccountEmail = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchAllauthClientV1AccountEmail>>, TError,{client: 'app' | 'browser';data: MarkPrimaryEmailBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patchAllauthClientV1AccountEmail>>,
        TError,
        {client: 'app' | 'browser';data: MarkPrimaryEmailBody},
        TContext
      > => {

      const mutationOptions = getPatchAllauthClientV1AccountEmailMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * The following functionality is available:

  - Adding a new email address for an already signed in user (`ACCOUNT_CHANGE_EMAIL = False`).
  - Change to a new email address for an already signed in user   (`ACCOUNT_CHANGE_EMAIL = True`).
  - Change to a new email address during the email verification process at signup (`ACCOUNT_EMAIL_VERIFICATION_SUPPORTS_CHANGE = True`).

In all cases, an email verification mail will be sent containing a link or code that needs to be verified.

 * @summary Add/Change email address

 */
export const postAllauthClientV1AccountEmail = (
    client: 'app' | 'browser',
    emailBody: EmailBody,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<EmailAddressesResponse>(
      {url: `/_allauth/${client}/v1/account/email`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: emailBody, signal
    },
      options);
    }
  


export const getPostAllauthClientV1AccountEmailMutationOptions = <TError = ErrorResponse | AuthenticationOrReauthenticationResponse | ConflictResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AccountEmail>>, TError,{client: 'app' | 'browser';data: EmailBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AccountEmail>>, TError,{client: 'app' | 'browser';data: EmailBody}, TContext> => {

const mutationKey = ['postAllauthClientV1AccountEmail'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postAllauthClientV1AccountEmail>>, {client: 'app' | 'browser';data: EmailBody}> = (props) => {
          const {client,data} = props ?? {};

          return  postAllauthClientV1AccountEmail(client,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostAllauthClientV1AccountEmailMutationResult = NonNullable<Awaited<ReturnType<typeof postAllauthClientV1AccountEmail>>>
    export type PostAllauthClientV1AccountEmailMutationBody = EmailBody
    export type PostAllauthClientV1AccountEmailMutationError = ErrorResponse | AuthenticationOrReauthenticationResponse | ConflictResponse

    /**
 * @summary Add/Change email address

 */
export const usePostAllauthClientV1AccountEmail = <TError = ErrorResponse | AuthenticationOrReauthenticationResponse | ConflictResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AccountEmail>>, TError,{client: 'app' | 'browser';data: EmailBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postAllauthClientV1AccountEmail>>,
        TError,
        {client: 'app' | 'browser';data: EmailBody},
        TContext
      > => {

      const mutationOptions = getPostAllauthClientV1AccountEmailMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Requests for (another) email verification email to be sent. Note that
sending emails is rate limited, so when you send too many requests the
email will not be sent.

 * @summary Request email verification
 */
export const putAllauthClientV1AccountEmail = (
    client: 'app' | 'browser',
    emailBody: EmailBody,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<StatusOKResponse>(
      {url: `/_allauth/${client}/v1/account/email`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: emailBody
    },
      options);
    }
  


export const getPutAllauthClientV1AccountEmailMutationOptions = <TError = ErrorResponse | ForbiddenResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putAllauthClientV1AccountEmail>>, TError,{client: 'app' | 'browser';data: EmailBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof putAllauthClientV1AccountEmail>>, TError,{client: 'app' | 'browser';data: EmailBody}, TContext> => {

const mutationKey = ['putAllauthClientV1AccountEmail'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putAllauthClientV1AccountEmail>>, {client: 'app' | 'browser';data: EmailBody}> = (props) => {
          const {client,data} = props ?? {};

          return  putAllauthClientV1AccountEmail(client,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutAllauthClientV1AccountEmailMutationResult = NonNullable<Awaited<ReturnType<typeof putAllauthClientV1AccountEmail>>>
    export type PutAllauthClientV1AccountEmailMutationBody = EmailBody
    export type PutAllauthClientV1AccountEmailMutationError = ErrorResponse | ForbiddenResponse

    /**
 * @summary Request email verification
 */
export const usePutAllauthClientV1AccountEmail = <TError = ErrorResponse | ForbiddenResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putAllauthClientV1AccountEmail>>, TError,{client: 'app' | 'browser';data: EmailBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof putAllauthClientV1AccountEmail>>,
        TError,
        {client: 'app' | 'browser';data: EmailBody},
        TContext
      > => {

      const mutationOptions = getPutAllauthClientV1AccountEmailMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * In order to change the password of an account, the current and new
password must be provider.  However, accounts that were created by
signing up using a third-party provider do not have a password set. In
that case, the current password is not required.

 * @summary Change password
 */
export const postAllauthClientV1AccountPasswordChange = (
    client: 'app' | 'browser',
    changePasswordBody: ChangePasswordBody,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/_allauth/${client}/v1/account/password/change`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: changePasswordBody, signal
    },
      options);
    }
  


export const getPostAllauthClientV1AccountPasswordChangeMutationOptions = <TError = ErrorResponse | AuthenticationResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AccountPasswordChange>>, TError,{client: 'app' | 'browser';data: ChangePasswordBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AccountPasswordChange>>, TError,{client: 'app' | 'browser';data: ChangePasswordBody}, TContext> => {

const mutationKey = ['postAllauthClientV1AccountPasswordChange'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postAllauthClientV1AccountPasswordChange>>, {client: 'app' | 'browser';data: ChangePasswordBody}> = (props) => {
          const {client,data} = props ?? {};

          return  postAllauthClientV1AccountPasswordChange(client,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostAllauthClientV1AccountPasswordChangeMutationResult = NonNullable<Awaited<ReturnType<typeof postAllauthClientV1AccountPasswordChange>>>
    export type PostAllauthClientV1AccountPasswordChangeMutationBody = ChangePasswordBody
    export type PostAllauthClientV1AccountPasswordChangeMutationError = ErrorResponse | AuthenticationResponse

    /**
 * @summary Change password
 */
export const usePostAllauthClientV1AccountPasswordChange = <TError = ErrorResponse | AuthenticationResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AccountPasswordChange>>, TError,{client: 'app' | 'browser';data: ChangePasswordBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postAllauthClientV1AccountPasswordChange>>,
        TError,
        {client: 'app' | 'browser';data: ChangePasswordBody},
        TContext
      > => {

      const mutationOptions = getPostAllauthClientV1AccountPasswordChangeMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieves the phone number of the account, if any. Note that while the
endpoint returns a list of phone numbers, at most one entry is returned.

 * @summary Get the phone number
 */
export const getAllauthClientV1AccountPhone = (
    client: 'app' | 'browser',
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PhoneNumbersResponse>(
      {url: `/_allauth/${client}/v1/account/phone`, method: 'GET', signal
    },
      options);
    }
  

export const getGetAllauthClientV1AccountPhoneQueryKey = (client: 'app' | 'browser',) => {
    return [`/_allauth/${client}/v1/account/phone`] as const;
    }

    
export const getGetAllauthClientV1AccountPhoneQueryOptions = <TData = Awaited<ReturnType<typeof getAllauthClientV1AccountPhone>>, TError = AuthenticationResponse>(client: 'app' | 'browser', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AccountPhone>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllauthClientV1AccountPhoneQueryKey(client);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllauthClientV1AccountPhone>>> = ({ signal }) => getAllauthClientV1AccountPhone(client, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(client), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AccountPhone>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllauthClientV1AccountPhoneQueryResult = NonNullable<Awaited<ReturnType<typeof getAllauthClientV1AccountPhone>>>
export type GetAllauthClientV1AccountPhoneQueryError = AuthenticationResponse


export function useGetAllauthClientV1AccountPhone<TData = Awaited<ReturnType<typeof getAllauthClientV1AccountPhone>>, TError = AuthenticationResponse>(
 client: 'app' | 'browser', options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AccountPhone>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllauthClientV1AccountPhone>>,
          TError,
          Awaited<ReturnType<typeof getAllauthClientV1AccountPhone>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllauthClientV1AccountPhone<TData = Awaited<ReturnType<typeof getAllauthClientV1AccountPhone>>, TError = AuthenticationResponse>(
 client: 'app' | 'browser', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AccountPhone>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllauthClientV1AccountPhone>>,
          TError,
          Awaited<ReturnType<typeof getAllauthClientV1AccountPhone>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllauthClientV1AccountPhone<TData = Awaited<ReturnType<typeof getAllauthClientV1AccountPhone>>, TError = AuthenticationResponse>(
 client: 'app' | 'browser', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AccountPhone>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get the phone number
 */

export function useGetAllauthClientV1AccountPhone<TData = Awaited<ReturnType<typeof getAllauthClientV1AccountPhone>>, TError = AuthenticationResponse>(
 client: 'app' | 'browser', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AccountPhone>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllauthClientV1AccountPhoneQueryOptions(client,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * The following functionality is available:

- Initiate the phone number change process for signed in users.
- Change to a new phone number during the phone number verification
  process at signup for unauthenticated users. Note that this requires:
  `ACCOUNT_PHONE_VERIFICATION_SUPPORTS_CHANGE = True`.

In both cases, after posting a new phone number, proceed with the phone
verification endpoint to confirm the change of the phone number by
posting the verification code.

 * @summary Change the phone number

 */
export const postAllauthClientV1AccountPhone = (
    client: 'app' | 'browser',
    phoneBody: PhoneBody,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PhoneNumberChangeResponse>(
      {url: `/_allauth/${client}/v1/account/phone`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: phoneBody, signal
    },
      options);
    }
  


export const getPostAllauthClientV1AccountPhoneMutationOptions = <TError = ErrorResponse | AuthenticationOrReauthenticationResponse | ConflictResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AccountPhone>>, TError,{client: 'app' | 'browser';data: PhoneBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AccountPhone>>, TError,{client: 'app' | 'browser';data: PhoneBody}, TContext> => {

const mutationKey = ['postAllauthClientV1AccountPhone'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postAllauthClientV1AccountPhone>>, {client: 'app' | 'browser';data: PhoneBody}> = (props) => {
          const {client,data} = props ?? {};

          return  postAllauthClientV1AccountPhone(client,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostAllauthClientV1AccountPhoneMutationResult = NonNullable<Awaited<ReturnType<typeof postAllauthClientV1AccountPhone>>>
    export type PostAllauthClientV1AccountPhoneMutationBody = PhoneBody
    export type PostAllauthClientV1AccountPhoneMutationError = ErrorResponse | AuthenticationOrReauthenticationResponse | ConflictResponse

    /**
 * @summary Change the phone number

 */
export const usePostAllauthClientV1AccountPhone = <TError = ErrorResponse | AuthenticationOrReauthenticationResponse | ConflictResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AccountPhone>>, TError,{client: 'app' | 'browser';data: PhoneBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postAllauthClientV1AccountPhone>>,
        TError,
        {client: 'app' | 'browser';data: PhoneBody},
        TContext
      > => {

      const mutationOptions = getPostAllauthClientV1AccountPhoneMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * If, during authentication,  a response with status 401 is encountered where one of the pending
flows has ID `mfa_authenticate`, that indicates that the Two-Factor Authentication stage needs to
be completed.

 * @summary Two-factor authentication
 */
export const postAllauthClientV1Auth2faAuthenticate = (
    client: 'app' | 'browser',
    mFAAuthenticateBody: MFAAuthenticateBody,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<AuthenticatedByPasswordAnd2FAResponse>(
      {url: `/_allauth/${client}/v1/auth/2fa/authenticate`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: mFAAuthenticateBody, signal
    },
      options);
    }
  


export const getPostAllauthClientV1Auth2faAuthenticateMutationOptions = <TError = ErrorResponse | AuthenticationResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1Auth2faAuthenticate>>, TError,{client: 'app' | 'browser';data: MFAAuthenticateBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1Auth2faAuthenticate>>, TError,{client: 'app' | 'browser';data: MFAAuthenticateBody}, TContext> => {

const mutationKey = ['postAllauthClientV1Auth2faAuthenticate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postAllauthClientV1Auth2faAuthenticate>>, {client: 'app' | 'browser';data: MFAAuthenticateBody}> = (props) => {
          const {client,data} = props ?? {};

          return  postAllauthClientV1Auth2faAuthenticate(client,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostAllauthClientV1Auth2faAuthenticateMutationResult = NonNullable<Awaited<ReturnType<typeof postAllauthClientV1Auth2faAuthenticate>>>
    export type PostAllauthClientV1Auth2faAuthenticateMutationBody = MFAAuthenticateBody
    export type PostAllauthClientV1Auth2faAuthenticateMutationError = ErrorResponse | AuthenticationResponse

    /**
 * @summary Two-factor authentication
 */
export const usePostAllauthClientV1Auth2faAuthenticate = <TError = ErrorResponse | AuthenticationResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1Auth2faAuthenticate>>, TError,{client: 'app' | 'browser';data: MFAAuthenticateBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postAllauthClientV1Auth2faAuthenticate>>,
        TError,
        {client: 'app' | 'browser';data: MFAAuthenticateBody},
        TContext
      > => {

      const mutationOptions = getPostAllauthClientV1Auth2faAuthenticateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * In order to safeguard the account, some actions require the user to be
recently authenticated.  If you try to perform such an action without
having been recently authenticated, a `401` status is returned, listing
flows that can be performed to reauthenticate. One such flow is the flow
with ID `mfa_reauthenticate`, which allows for the user to input an
authenticator code (e.g. TOTP or recovery code). This is the endpoint
related towards that flow.

 * @summary Reauthenticate using 2FA
 */
export const postAllauthClientV1Auth2faReauthenticate = (
    client: 'app' | 'browser',
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<AuthenticatedByPasswordAnd2FAResponse>(
      {url: `/_allauth/${client}/v1/auth/2fa/reauthenticate`, method: 'POST', signal
    },
      options);
    }
  


export const getPostAllauthClientV1Auth2faReauthenticateMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1Auth2faReauthenticate>>, TError,{client: 'app' | 'browser'}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1Auth2faReauthenticate>>, TError,{client: 'app' | 'browser'}, TContext> => {

const mutationKey = ['postAllauthClientV1Auth2faReauthenticate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postAllauthClientV1Auth2faReauthenticate>>, {client: 'app' | 'browser'}> = (props) => {
          const {client} = props ?? {};

          return  postAllauthClientV1Auth2faReauthenticate(client,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostAllauthClientV1Auth2faReauthenticateMutationResult = NonNullable<Awaited<ReturnType<typeof postAllauthClientV1Auth2faReauthenticate>>>
    
    export type PostAllauthClientV1Auth2faReauthenticateMutationError = ErrorResponse

    /**
 * @summary Reauthenticate using 2FA
 */
export const usePostAllauthClientV1Auth2faReauthenticate = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1Auth2faReauthenticate>>, TError,{client: 'app' | 'browser'}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postAllauthClientV1Auth2faReauthenticate>>,
        TError,
        {client: 'app' | 'browser'},
        TContext
      > => {

      const mutationOptions = getPostAllauthClientV1Auth2faReauthenticateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Use this endpoint to pass along the received "special" login code.

 * @summary Confirm login code
 */
export const postAllauthClientV1AuthCodeConfirm = (
    client: 'app' | 'browser',
    confirmLoginCodeBody: ConfirmLoginCodeBody,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<AuthenticatedByCodeResponse>(
      {url: `/_allauth/${client}/v1/auth/code/confirm`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: confirmLoginCodeBody, signal
    },
      options);
    }
  


export const getPostAllauthClientV1AuthCodeConfirmMutationOptions = <TError = ErrorResponse | AuthenticationResponse | ConflictResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AuthCodeConfirm>>, TError,{client: 'app' | 'browser';data: ConfirmLoginCodeBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AuthCodeConfirm>>, TError,{client: 'app' | 'browser';data: ConfirmLoginCodeBody}, TContext> => {

const mutationKey = ['postAllauthClientV1AuthCodeConfirm'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postAllauthClientV1AuthCodeConfirm>>, {client: 'app' | 'browser';data: ConfirmLoginCodeBody}> = (props) => {
          const {client,data} = props ?? {};

          return  postAllauthClientV1AuthCodeConfirm(client,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostAllauthClientV1AuthCodeConfirmMutationResult = NonNullable<Awaited<ReturnType<typeof postAllauthClientV1AuthCodeConfirm>>>
    export type PostAllauthClientV1AuthCodeConfirmMutationBody = ConfirmLoginCodeBody
    export type PostAllauthClientV1AuthCodeConfirmMutationError = ErrorResponse | AuthenticationResponse | ConflictResponse

    /**
 * @summary Confirm login code
 */
export const usePostAllauthClientV1AuthCodeConfirm = <TError = ErrorResponse | AuthenticationResponse | ConflictResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AuthCodeConfirm>>, TError,{client: 'app' | 'browser';data: ConfirmLoginCodeBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postAllauthClientV1AuthCodeConfirm>>,
        TError,
        {client: 'app' | 'browser';data: ConfirmLoginCodeBody},
        TContext
      > => {

      const mutationOptions = getPostAllauthClientV1AuthCodeConfirmMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Request a "special" login code that is sent to the user by email.

 * @summary Request login code
 */
export const postAllauthClientV1AuthCodeRequest = (
    client: 'app' | 'browser',
    requestLoginCodeBody: RequestLoginCodeBody,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/_allauth/${client}/v1/auth/code/request`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: requestLoginCodeBody, signal
    },
      options);
    }
  


export const getPostAllauthClientV1AuthCodeRequestMutationOptions = <TError = ErrorResponse | AuthenticationResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AuthCodeRequest>>, TError,{client: 'app' | 'browser';data: RequestLoginCodeBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AuthCodeRequest>>, TError,{client: 'app' | 'browser';data: RequestLoginCodeBody}, TContext> => {

const mutationKey = ['postAllauthClientV1AuthCodeRequest'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postAllauthClientV1AuthCodeRequest>>, {client: 'app' | 'browser';data: RequestLoginCodeBody}> = (props) => {
          const {client,data} = props ?? {};

          return  postAllauthClientV1AuthCodeRequest(client,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostAllauthClientV1AuthCodeRequestMutationResult = NonNullable<Awaited<ReturnType<typeof postAllauthClientV1AuthCodeRequest>>>
    export type PostAllauthClientV1AuthCodeRequestMutationBody = RequestLoginCodeBody
    export type PostAllauthClientV1AuthCodeRequestMutationError = ErrorResponse | AuthenticationResponse

    /**
 * @summary Request login code
 */
export const usePostAllauthClientV1AuthCodeRequest = <TError = ErrorResponse | AuthenticationResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AuthCodeRequest>>, TError,{client: 'app' | 'browser';data: RequestLoginCodeBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postAllauthClientV1AuthCodeRequest>>,
        TError,
        {client: 'app' | 'browser';data: RequestLoginCodeBody},
        TContext
      > => {

      const mutationOptions = getPostAllauthClientV1AuthCodeRequestMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Obtain email verification information, given the token that was sent to
the user by email.

 * @summary Get email verification information
 */
export const getAllauthClientV1AuthEmailVerify = (
    client: 'app' | 'browser',
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<EmailVerificationInfoResponse>(
      {url: `/_allauth/${client}/v1/auth/email/verify`, method: 'GET', signal
    },
      options);
    }
  

export const getGetAllauthClientV1AuthEmailVerifyQueryKey = (client: 'app' | 'browser',) => {
    return [`/_allauth/${client}/v1/auth/email/verify`] as const;
    }

    
export const getGetAllauthClientV1AuthEmailVerifyQueryOptions = <TData = Awaited<ReturnType<typeof getAllauthClientV1AuthEmailVerify>>, TError = ErrorResponse | ConflictResponse>(client: 'app' | 'browser', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AuthEmailVerify>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllauthClientV1AuthEmailVerifyQueryKey(client);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllauthClientV1AuthEmailVerify>>> = ({ signal }) => getAllauthClientV1AuthEmailVerify(client, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(client), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AuthEmailVerify>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllauthClientV1AuthEmailVerifyQueryResult = NonNullable<Awaited<ReturnType<typeof getAllauthClientV1AuthEmailVerify>>>
export type GetAllauthClientV1AuthEmailVerifyQueryError = ErrorResponse | ConflictResponse


export function useGetAllauthClientV1AuthEmailVerify<TData = Awaited<ReturnType<typeof getAllauthClientV1AuthEmailVerify>>, TError = ErrorResponse | ConflictResponse>(
 client: 'app' | 'browser', options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AuthEmailVerify>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllauthClientV1AuthEmailVerify>>,
          TError,
          Awaited<ReturnType<typeof getAllauthClientV1AuthEmailVerify>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllauthClientV1AuthEmailVerify<TData = Awaited<ReturnType<typeof getAllauthClientV1AuthEmailVerify>>, TError = ErrorResponse | ConflictResponse>(
 client: 'app' | 'browser', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AuthEmailVerify>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllauthClientV1AuthEmailVerify>>,
          TError,
          Awaited<ReturnType<typeof getAllauthClientV1AuthEmailVerify>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllauthClientV1AuthEmailVerify<TData = Awaited<ReturnType<typeof getAllauthClientV1AuthEmailVerify>>, TError = ErrorResponse | ConflictResponse>(
 client: 'app' | 'browser', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AuthEmailVerify>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get email verification information
 */

export function useGetAllauthClientV1AuthEmailVerify<TData = Awaited<ReturnType<typeof getAllauthClientV1AuthEmailVerify>>, TError = ErrorResponse | ConflictResponse>(
 client: 'app' | 'browser', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AuthEmailVerify>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllauthClientV1AuthEmailVerifyQueryOptions(client,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Complete the email verification process. Depending on the configuration,
email addresses are either verified by opening a link that is sent to
their email address, or, by inputting a code that is sent. On the API,
both cases are handled identically. Meaning, the required key is either
the one from the link, or, the code itself.

Note that a status code of 401 does not imply failure. It indicates that
the email verification was successful, yet, the user is still not signed
in. For example, in case `ACCOUNT_LOGIN_ON_EMAIL_CONFIRMATION` is set to
`False`, a 401 is returned when verifying as part of login/signup.

 * @summary Verify an email
 */
export const postAllauthClientV1AuthEmailVerify = (
    client: 'app' | 'browser',
    verifyEmailBody: VerifyEmailBody,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<AuthenticatedResponse>(
      {url: `/_allauth/${client}/v1/auth/email/verify`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: verifyEmailBody, signal
    },
      options);
    }
  


export const getPostAllauthClientV1AuthEmailVerifyMutationOptions = <TError = ErrorResponse | UnauthenticatedResponse | ConflictResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AuthEmailVerify>>, TError,{client: 'app' | 'browser';data: VerifyEmailBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AuthEmailVerify>>, TError,{client: 'app' | 'browser';data: VerifyEmailBody}, TContext> => {

const mutationKey = ['postAllauthClientV1AuthEmailVerify'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postAllauthClientV1AuthEmailVerify>>, {client: 'app' | 'browser';data: VerifyEmailBody}> = (props) => {
          const {client,data} = props ?? {};

          return  postAllauthClientV1AuthEmailVerify(client,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostAllauthClientV1AuthEmailVerifyMutationResult = NonNullable<Awaited<ReturnType<typeof postAllauthClientV1AuthEmailVerify>>>
    export type PostAllauthClientV1AuthEmailVerifyMutationBody = VerifyEmailBody
    export type PostAllauthClientV1AuthEmailVerifyMutationError = ErrorResponse | UnauthenticatedResponse | ConflictResponse

    /**
 * @summary Verify an email
 */
export const usePostAllauthClientV1AuthEmailVerify = <TError = ErrorResponse | UnauthenticatedResponse | ConflictResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AuthEmailVerify>>, TError,{client: 'app' | 'browser';data: VerifyEmailBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postAllauthClientV1AuthEmailVerify>>,
        TError,
        {client: 'app' | 'browser';data: VerifyEmailBody},
        TContext
      > => {

      const mutationOptions = getPostAllauthClientV1AuthEmailVerifyMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Requests a new email verification code.
Requires `ACCOUNT_EMAIL_VERIFICATION_SUPPORTS_RESEND = True`.

 * @summary Resend email verification code
 */
export const postAllauthClientV1AuthEmailVerifyResend = (
    client: 'app' | 'browser',
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<StatusOKResponse>(
      {url: `/_allauth/${client}/v1/auth/email/verify/resend`, method: 'POST', signal
    },
      options);
    }
  


export const getPostAllauthClientV1AuthEmailVerifyResendMutationOptions = <TError = ConflictResponse | TooManyRequestsResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AuthEmailVerifyResend>>, TError,{client: 'app' | 'browser'}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AuthEmailVerifyResend>>, TError,{client: 'app' | 'browser'}, TContext> => {

const mutationKey = ['postAllauthClientV1AuthEmailVerifyResend'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postAllauthClientV1AuthEmailVerifyResend>>, {client: 'app' | 'browser'}> = (props) => {
          const {client} = props ?? {};

          return  postAllauthClientV1AuthEmailVerifyResend(client,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostAllauthClientV1AuthEmailVerifyResendMutationResult = NonNullable<Awaited<ReturnType<typeof postAllauthClientV1AuthEmailVerifyResend>>>
    
    export type PostAllauthClientV1AuthEmailVerifyResendMutationError = ConflictResponse | TooManyRequestsResponse

    /**
 * @summary Resend email verification code
 */
export const usePostAllauthClientV1AuthEmailVerifyResend = <TError = ConflictResponse | TooManyRequestsResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AuthEmailVerifyResend>>, TError,{client: 'app' | 'browser'}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postAllauthClientV1AuthEmailVerifyResend>>,
        TError,
        {client: 'app' | 'browser'},
        TContext
      > => {

      const mutationOptions = getPostAllauthClientV1AuthEmailVerifyResendMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Login using a username-password or email-password combination.

 * @summary Login
 */
export const postAllauthClientV1AuthLogin = (
    client: 'app' | 'browser',
    loginBody: LoginBody,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<AuthenticatedByPasswordResponse>(
      {url: `/_allauth/${client}/v1/auth/login`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: loginBody, signal
    },
      options);
    }
  


export const getPostAllauthClientV1AuthLoginMutationOptions = <TError = ErrorResponse | AuthenticationResponse | ConflictResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AuthLogin>>, TError,{client: 'app' | 'browser';data: LoginBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AuthLogin>>, TError,{client: 'app' | 'browser';data: LoginBody}, TContext> => {

const mutationKey = ['postAllauthClientV1AuthLogin'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postAllauthClientV1AuthLogin>>, {client: 'app' | 'browser';data: LoginBody}> = (props) => {
          const {client,data} = props ?? {};

          return  postAllauthClientV1AuthLogin(client,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostAllauthClientV1AuthLoginMutationResult = NonNullable<Awaited<ReturnType<typeof postAllauthClientV1AuthLogin>>>
    export type PostAllauthClientV1AuthLoginMutationBody = LoginBody
    export type PostAllauthClientV1AuthLoginMutationError = ErrorResponse | AuthenticationResponse | ConflictResponse

    /**
 * @summary Login
 */
export const usePostAllauthClientV1AuthLogin = <TError = ErrorResponse | AuthenticationResponse | ConflictResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AuthLogin>>, TError,{client: 'app' | 'browser';data: LoginBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postAllauthClientV1AuthLogin>>,
        TError,
        {client: 'app' | 'browser';data: LoginBody},
        TContext
      > => {

      const mutationOptions = getPostAllauthClientV1AuthLoginMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Initiates the password reset procedure. Depending on whether or not
`ACCOUNT_PASSWORD_RESET_BY_CODE_ENABLED` is `True`, the procedure is
either stateless or stateful.

In case codes are used, it is stateful, and a new
`password_reset_by_code` flow is started. In this case, on a successful
password reset request, you will receive a 401 indicating the pending
status of this flow.

In case password reset is configured to use (stateless) links, you will
receive a 200 on a successful password reset request.

 * @summary Request password
 */
export const postAllauthClientV1AuthPasswordRequest = (
    client: 'app' | 'browser',
    requestPasswordBody: RequestPasswordBody,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<StatusOKResponse>(
      {url: `/_allauth/${client}/v1/auth/password/request`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: requestPasswordBody, signal
    },
      options);
    }
  


export const getPostAllauthClientV1AuthPasswordRequestMutationOptions = <TError = ErrorResponse | AuthenticationResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AuthPasswordRequest>>, TError,{client: 'app' | 'browser';data: RequestPasswordBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AuthPasswordRequest>>, TError,{client: 'app' | 'browser';data: RequestPasswordBody}, TContext> => {

const mutationKey = ['postAllauthClientV1AuthPasswordRequest'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postAllauthClientV1AuthPasswordRequest>>, {client: 'app' | 'browser';data: RequestPasswordBody}> = (props) => {
          const {client,data} = props ?? {};

          return  postAllauthClientV1AuthPasswordRequest(client,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostAllauthClientV1AuthPasswordRequestMutationResult = NonNullable<Awaited<ReturnType<typeof postAllauthClientV1AuthPasswordRequest>>>
    export type PostAllauthClientV1AuthPasswordRequestMutationBody = RequestPasswordBody
    export type PostAllauthClientV1AuthPasswordRequestMutationError = ErrorResponse | AuthenticationResponse

    /**
 * @summary Request password
 */
export const usePostAllauthClientV1AuthPasswordRequest = <TError = ErrorResponse | AuthenticationResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AuthPasswordRequest>>, TError,{client: 'app' | 'browser';data: RequestPasswordBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postAllauthClientV1AuthPasswordRequest>>,
        TError,
        {client: 'app' | 'browser';data: RequestPasswordBody},
        TContext
      > => {

      const mutationOptions = getPostAllauthClientV1AuthPasswordRequestMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Used to obtain information on and validate a password reset key.  The
key passed is either the key encoded in the password reset URL that the
user has received per email, or, the password reset code in case of
`ACCOUNT_PASSWORD_RESET_BY_CODE_ENABLED`. Note that in case of a code,
the number of requests you can make is limited (by
`ACCOUNT_PASSWORD_RESET_BY_CODE_MAX_ATTEMPTS`).

 * @summary Get password reset information
 */
export const getAllauthClientV1AuthPasswordReset = (
    client: 'app' | 'browser',
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PasswordResetInfoResponse>(
      {url: `/_allauth/${client}/v1/auth/password/reset`, method: 'GET', signal
    },
      options);
    }
  

export const getGetAllauthClientV1AuthPasswordResetQueryKey = (client: 'app' | 'browser',) => {
    return [`/_allauth/${client}/v1/auth/password/reset`] as const;
    }

    
export const getGetAllauthClientV1AuthPasswordResetQueryOptions = <TData = Awaited<ReturnType<typeof getAllauthClientV1AuthPasswordReset>>, TError = ErrorResponse | ConflictResponse>(client: 'app' | 'browser', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AuthPasswordReset>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllauthClientV1AuthPasswordResetQueryKey(client);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllauthClientV1AuthPasswordReset>>> = ({ signal }) => getAllauthClientV1AuthPasswordReset(client, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(client), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AuthPasswordReset>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllauthClientV1AuthPasswordResetQueryResult = NonNullable<Awaited<ReturnType<typeof getAllauthClientV1AuthPasswordReset>>>
export type GetAllauthClientV1AuthPasswordResetQueryError = ErrorResponse | ConflictResponse


export function useGetAllauthClientV1AuthPasswordReset<TData = Awaited<ReturnType<typeof getAllauthClientV1AuthPasswordReset>>, TError = ErrorResponse | ConflictResponse>(
 client: 'app' | 'browser', options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AuthPasswordReset>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllauthClientV1AuthPasswordReset>>,
          TError,
          Awaited<ReturnType<typeof getAllauthClientV1AuthPasswordReset>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllauthClientV1AuthPasswordReset<TData = Awaited<ReturnType<typeof getAllauthClientV1AuthPasswordReset>>, TError = ErrorResponse | ConflictResponse>(
 client: 'app' | 'browser', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AuthPasswordReset>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllauthClientV1AuthPasswordReset>>,
          TError,
          Awaited<ReturnType<typeof getAllauthClientV1AuthPasswordReset>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllauthClientV1AuthPasswordReset<TData = Awaited<ReturnType<typeof getAllauthClientV1AuthPasswordReset>>, TError = ErrorResponse | ConflictResponse>(
 client: 'app' | 'browser', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AuthPasswordReset>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get password reset information
 */

export function useGetAllauthClientV1AuthPasswordReset<TData = Awaited<ReturnType<typeof getAllauthClientV1AuthPasswordReset>>, TError = ErrorResponse | ConflictResponse>(
 client: 'app' | 'browser', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AuthPasswordReset>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllauthClientV1AuthPasswordResetQueryOptions(client,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Perform the password reset, by handing over the password reset key and
the new password. After successfully completing the password reset, the
user is either logged in (in case `ACCOUNT_LOGIN_ON_PASSWORD_RESET` is
`True`), or, the user will need to proceed to the login page.  In case
of the former, a `200` status code is returned, in case of the latter a
401.

 * @summary Reset password
 */
export const postAllauthClientV1AuthPasswordReset = (
    client: 'app' | 'browser',
    resetPasswordBody: ResetPasswordBody,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<AuthenticatedByPasswordResponse>(
      {url: `/_allauth/${client}/v1/auth/password/reset`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: resetPasswordBody, signal
    },
      options);
    }
  


export const getPostAllauthClientV1AuthPasswordResetMutationOptions = <TError = ErrorResponse | AuthenticationResponse | ConflictResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AuthPasswordReset>>, TError,{client: 'app' | 'browser';data: ResetPasswordBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AuthPasswordReset>>, TError,{client: 'app' | 'browser';data: ResetPasswordBody}, TContext> => {

const mutationKey = ['postAllauthClientV1AuthPasswordReset'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postAllauthClientV1AuthPasswordReset>>, {client: 'app' | 'browser';data: ResetPasswordBody}> = (props) => {
          const {client,data} = props ?? {};

          return  postAllauthClientV1AuthPasswordReset(client,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostAllauthClientV1AuthPasswordResetMutationResult = NonNullable<Awaited<ReturnType<typeof postAllauthClientV1AuthPasswordReset>>>
    export type PostAllauthClientV1AuthPasswordResetMutationBody = ResetPasswordBody
    export type PostAllauthClientV1AuthPasswordResetMutationError = ErrorResponse | AuthenticationResponse | ConflictResponse

    /**
 * @summary Reset password
 */
export const usePostAllauthClientV1AuthPasswordReset = <TError = ErrorResponse | AuthenticationResponse | ConflictResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AuthPasswordReset>>, TError,{client: 'app' | 'browser';data: ResetPasswordBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postAllauthClientV1AuthPasswordReset>>,
        TError,
        {client: 'app' | 'browser';data: ResetPasswordBody},
        TContext
      > => {

      const mutationOptions = getPostAllauthClientV1AuthPasswordResetMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Complete the phone number verification process. Note that a status code
of 401 does not imply failure. It merely indicates that the phone number
verification was successful, yet, the user is still not signed in.

 * @summary Verify a phone number
 */
export const postAllauthClientV1AuthPhoneVerify = (
    client: 'app' | 'browser',
    verifyPhoneBody: VerifyPhoneBody,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<AuthenticatedResponse>(
      {url: `/_allauth/${client}/v1/auth/phone/verify`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: verifyPhoneBody, signal
    },
      options);
    }
  


export const getPostAllauthClientV1AuthPhoneVerifyMutationOptions = <TError = ErrorResponse | UnauthenticatedResponse | ConflictResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AuthPhoneVerify>>, TError,{client: 'app' | 'browser';data: VerifyPhoneBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AuthPhoneVerify>>, TError,{client: 'app' | 'browser';data: VerifyPhoneBody}, TContext> => {

const mutationKey = ['postAllauthClientV1AuthPhoneVerify'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postAllauthClientV1AuthPhoneVerify>>, {client: 'app' | 'browser';data: VerifyPhoneBody}> = (props) => {
          const {client,data} = props ?? {};

          return  postAllauthClientV1AuthPhoneVerify(client,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostAllauthClientV1AuthPhoneVerifyMutationResult = NonNullable<Awaited<ReturnType<typeof postAllauthClientV1AuthPhoneVerify>>>
    export type PostAllauthClientV1AuthPhoneVerifyMutationBody = VerifyPhoneBody
    export type PostAllauthClientV1AuthPhoneVerifyMutationError = ErrorResponse | UnauthenticatedResponse | ConflictResponse

    /**
 * @summary Verify a phone number
 */
export const usePostAllauthClientV1AuthPhoneVerify = <TError = ErrorResponse | UnauthenticatedResponse | ConflictResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AuthPhoneVerify>>, TError,{client: 'app' | 'browser';data: VerifyPhoneBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postAllauthClientV1AuthPhoneVerify>>,
        TError,
        {client: 'app' | 'browser';data: VerifyPhoneBody},
        TContext
      > => {

      const mutationOptions = getPostAllauthClientV1AuthPhoneVerifyMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Requests a new phone number verification code.
Requires `ACCOUNT_PHONE_VERIFICATION_SUPPORTS_RESEND = True`.

 * @summary Resend phone number verification code
 */
export const postAllauthClientV1AuthPhoneVerifyResend = (
    client: 'app' | 'browser',
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<StatusOKResponse>(
      {url: `/_allauth/${client}/v1/auth/phone/verify/resend`, method: 'POST', signal
    },
      options);
    }
  


export const getPostAllauthClientV1AuthPhoneVerifyResendMutationOptions = <TError = ConflictResponse | TooManyRequestsResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AuthPhoneVerifyResend>>, TError,{client: 'app' | 'browser'}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AuthPhoneVerifyResend>>, TError,{client: 'app' | 'browser'}, TContext> => {

const mutationKey = ['postAllauthClientV1AuthPhoneVerifyResend'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postAllauthClientV1AuthPhoneVerifyResend>>, {client: 'app' | 'browser'}> = (props) => {
          const {client} = props ?? {};

          return  postAllauthClientV1AuthPhoneVerifyResend(client,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostAllauthClientV1AuthPhoneVerifyResendMutationResult = NonNullable<Awaited<ReturnType<typeof postAllauthClientV1AuthPhoneVerifyResend>>>
    
    export type PostAllauthClientV1AuthPhoneVerifyResendMutationError = ConflictResponse | TooManyRequestsResponse

    /**
 * @summary Resend phone number verification code
 */
export const usePostAllauthClientV1AuthPhoneVerifyResend = <TError = ConflictResponse | TooManyRequestsResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AuthPhoneVerifyResend>>, TError,{client: 'app' | 'browser'}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postAllauthClientV1AuthPhoneVerifyResend>>,
        TError,
        {client: 'app' | 'browser'},
        TContext
      > => {

      const mutationOptions = getPostAllauthClientV1AuthPhoneVerifyResendMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * In order to safeguard the account, some actions require the user to be
recently authenticated.  If you try to perform such an action without
having been recently authenticated, a `401` status is returned, listing
flows that can be performed to reauthenticate. One such flow is the flow
with ID `reauthenticate`, which allows for the user to input the
password. This is the endpoint related towards that flow.

 * @summary Reauthenticate
 */
export const postAllauthClientV1AuthReauthenticate = (
    client: 'app' | 'browser',
    reauthenticateBody: ReauthenticateBody,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<AuthenticatedByPasswordResponse>(
      {url: `/_allauth/${client}/v1/auth/reauthenticate`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: reauthenticateBody, signal
    },
      options);
    }
  


export const getPostAllauthClientV1AuthReauthenticateMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AuthReauthenticate>>, TError,{client: 'app' | 'browser';data: ReauthenticateBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AuthReauthenticate>>, TError,{client: 'app' | 'browser';data: ReauthenticateBody}, TContext> => {

const mutationKey = ['postAllauthClientV1AuthReauthenticate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postAllauthClientV1AuthReauthenticate>>, {client: 'app' | 'browser';data: ReauthenticateBody}> = (props) => {
          const {client,data} = props ?? {};

          return  postAllauthClientV1AuthReauthenticate(client,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostAllauthClientV1AuthReauthenticateMutationResult = NonNullable<Awaited<ReturnType<typeof postAllauthClientV1AuthReauthenticate>>>
    export type PostAllauthClientV1AuthReauthenticateMutationBody = ReauthenticateBody
    export type PostAllauthClientV1AuthReauthenticateMutationError = ErrorResponse

    /**
 * @summary Reauthenticate
 */
export const usePostAllauthClientV1AuthReauthenticate = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AuthReauthenticate>>, TError,{client: 'app' | 'browser';data: ReauthenticateBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postAllauthClientV1AuthReauthenticate>>,
        TError,
        {client: 'app' | 'browser';data: ReauthenticateBody},
        TContext
      > => {

      const mutationOptions = getPostAllauthClientV1AuthReauthenticateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Logs out the user from the current session.

 * @summary Logout
 */
export const deleteAllauthClientV1AuthSession = (
    client: 'app' | 'browser',
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<unknown>(
      {url: `/_allauth/${client}/v1/auth/session`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteAllauthClientV1AuthSessionMutationOptions = <TError = UnauthenticatedResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAllauthClientV1AuthSession>>, TError,{client: 'app' | 'browser'}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteAllauthClientV1AuthSession>>, TError,{client: 'app' | 'browser'}, TContext> => {

const mutationKey = ['deleteAllauthClientV1AuthSession'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteAllauthClientV1AuthSession>>, {client: 'app' | 'browser'}> = (props) => {
          const {client} = props ?? {};

          return  deleteAllauthClientV1AuthSession(client,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteAllauthClientV1AuthSessionMutationResult = NonNullable<Awaited<ReturnType<typeof deleteAllauthClientV1AuthSession>>>
    
    export type DeleteAllauthClientV1AuthSessionMutationError = UnauthenticatedResponse

    /**
 * @summary Logout
 */
export const useDeleteAllauthClientV1AuthSession = <TError = UnauthenticatedResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAllauthClientV1AuthSession>>, TError,{client: 'app' | 'browser'}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteAllauthClientV1AuthSession>>,
        TError,
        {client: 'app' | 'browser'},
        TContext
      > => {

      const mutationOptions = getDeleteAllauthClientV1AuthSessionMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve information about the authentication status for the current
session.

 * @summary Get authentication status

 */
export const getAllauthClientV1AuthSession = (
    client: 'app' | 'browser',
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<AuthenticatedResponse>(
      {url: `/_allauth/${client}/v1/auth/session`, method: 'GET', signal
    },
      options);
    }
  

export const getGetAllauthClientV1AuthSessionQueryKey = (client: 'app' | 'browser',) => {
    return [`/_allauth/${client}/v1/auth/session`] as const;
    }

    
export const getGetAllauthClientV1AuthSessionQueryOptions = <TData = Awaited<ReturnType<typeof getAllauthClientV1AuthSession>>, TError = AuthenticationResponse | SessionGoneResponse>(client: 'app' | 'browser', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AuthSession>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllauthClientV1AuthSessionQueryKey(client);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllauthClientV1AuthSession>>> = ({ signal }) => getAllauthClientV1AuthSession(client, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(client), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AuthSession>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllauthClientV1AuthSessionQueryResult = NonNullable<Awaited<ReturnType<typeof getAllauthClientV1AuthSession>>>
export type GetAllauthClientV1AuthSessionQueryError = AuthenticationResponse | SessionGoneResponse


export function useGetAllauthClientV1AuthSession<TData = Awaited<ReturnType<typeof getAllauthClientV1AuthSession>>, TError = AuthenticationResponse | SessionGoneResponse>(
 client: 'app' | 'browser', options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AuthSession>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllauthClientV1AuthSession>>,
          TError,
          Awaited<ReturnType<typeof getAllauthClientV1AuthSession>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllauthClientV1AuthSession<TData = Awaited<ReturnType<typeof getAllauthClientV1AuthSession>>, TError = AuthenticationResponse | SessionGoneResponse>(
 client: 'app' | 'browser', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AuthSession>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllauthClientV1AuthSession>>,
          TError,
          Awaited<ReturnType<typeof getAllauthClientV1AuthSession>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllauthClientV1AuthSession<TData = Awaited<ReturnType<typeof getAllauthClientV1AuthSession>>, TError = AuthenticationResponse | SessionGoneResponse>(
 client: 'app' | 'browser', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AuthSession>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get authentication status

 */

export function useGetAllauthClientV1AuthSession<TData = Awaited<ReturnType<typeof getAllauthClientV1AuthSession>>, TError = AuthenticationResponse | SessionGoneResponse>(
 client: 'app' | 'browser', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AuthSession>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllauthClientV1AuthSessionQueryOptions(client,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Whether or not `username`, `email`, `phone` or combination of those are
required depends on the configuration of django-allauth. Additionally,
if a custom signup form is used there may be other custom properties
required.

 * @summary Signup
 */
export const postAllauthClientV1AuthSignup = (
    client: 'app' | 'browser',
    signupBody: SignupBody,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<AuthenticatedByPasswordResponse>(
      {url: `/_allauth/${client}/v1/auth/signup`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: signupBody, signal
    },
      options);
    }
  


export const getPostAllauthClientV1AuthSignupMutationOptions = <TError = ErrorResponse | AuthenticationResponse | ForbiddenResponse | ConflictResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AuthSignup>>, TError,{client: 'app' | 'browser';data: SignupBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AuthSignup>>, TError,{client: 'app' | 'browser';data: SignupBody}, TContext> => {

const mutationKey = ['postAllauthClientV1AuthSignup'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postAllauthClientV1AuthSignup>>, {client: 'app' | 'browser';data: SignupBody}> = (props) => {
          const {client,data} = props ?? {};

          return  postAllauthClientV1AuthSignup(client,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostAllauthClientV1AuthSignupMutationResult = NonNullable<Awaited<ReturnType<typeof postAllauthClientV1AuthSignup>>>
    export type PostAllauthClientV1AuthSignupMutationBody = SignupBody
    export type PostAllauthClientV1AuthSignupMutationError = ErrorResponse | AuthenticationResponse | ForbiddenResponse | ConflictResponse

    /**
 * @summary Signup
 */
export const usePostAllauthClientV1AuthSignup = <TError = ErrorResponse | AuthenticationResponse | ForbiddenResponse | ConflictResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AuthSignup>>, TError,{client: 'app' | 'browser';data: SignupBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postAllauthClientV1AuthSignup>>,
        TError,
        {client: 'app' | 'browser';data: SignupBody},
        TContext
      > => {

      const mutationOptions = getPostAllauthClientV1AuthSignupMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Returns the WebAuthn credential request options, that can be
processed using `parseRequestOptionsFromJSON()` on the frontend.

 * @summary Get WebAuthn credential request options for 2FA
 */
export const getAllauthClientV1AuthWebauthnAuthenticate = (
    client: 'app' | 'browser',
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<WebAuthnRequestOptionsResponseResponse>(
      {url: `/_allauth/${client}/v1/auth/webauthn/authenticate`, method: 'GET', signal
    },
      options);
    }
  

export const getGetAllauthClientV1AuthWebauthnAuthenticateQueryKey = (client: 'app' | 'browser',) => {
    return [`/_allauth/${client}/v1/auth/webauthn/authenticate`] as const;
    }

    
export const getGetAllauthClientV1AuthWebauthnAuthenticateQueryOptions = <TData = Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnAuthenticate>>, TError = unknown>(client: 'app' | 'browser', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnAuthenticate>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllauthClientV1AuthWebauthnAuthenticateQueryKey(client);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnAuthenticate>>> = ({ signal }) => getAllauthClientV1AuthWebauthnAuthenticate(client, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(client), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnAuthenticate>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllauthClientV1AuthWebauthnAuthenticateQueryResult = NonNullable<Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnAuthenticate>>>
export type GetAllauthClientV1AuthWebauthnAuthenticateQueryError = unknown


export function useGetAllauthClientV1AuthWebauthnAuthenticate<TData = Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnAuthenticate>>, TError = unknown>(
 client: 'app' | 'browser', options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnAuthenticate>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnAuthenticate>>,
          TError,
          Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnAuthenticate>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllauthClientV1AuthWebauthnAuthenticate<TData = Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnAuthenticate>>, TError = unknown>(
 client: 'app' | 'browser', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnAuthenticate>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnAuthenticate>>,
          TError,
          Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnAuthenticate>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllauthClientV1AuthWebauthnAuthenticate<TData = Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnAuthenticate>>, TError = unknown>(
 client: 'app' | 'browser', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnAuthenticate>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get WebAuthn credential request options for 2FA
 */

export function useGetAllauthClientV1AuthWebauthnAuthenticate<TData = Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnAuthenticate>>, TError = unknown>(
 client: 'app' | 'browser', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnAuthenticate>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllauthClientV1AuthWebauthnAuthenticateQueryOptions(client,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Perform Two-Factor Authentication using a WebAuthn credential.

 * @summary Perform 2FA using WebAuthn
 */
export const postAllauthClientV1AuthWebauthnAuthenticate = (
    client: 'app' | 'browser',
    authenticateWebAuthnBody: AuthenticateWebAuthnBody,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<AuthenticatedResponse>(
      {url: `/_allauth/${client}/v1/auth/webauthn/authenticate`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: authenticateWebAuthnBody, signal
    },
      options);
    }
  


export const getPostAllauthClientV1AuthWebauthnAuthenticateMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AuthWebauthnAuthenticate>>, TError,{client: 'app' | 'browser';data: AuthenticateWebAuthnBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AuthWebauthnAuthenticate>>, TError,{client: 'app' | 'browser';data: AuthenticateWebAuthnBody}, TContext> => {

const mutationKey = ['postAllauthClientV1AuthWebauthnAuthenticate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postAllauthClientV1AuthWebauthnAuthenticate>>, {client: 'app' | 'browser';data: AuthenticateWebAuthnBody}> = (props) => {
          const {client,data} = props ?? {};

          return  postAllauthClientV1AuthWebauthnAuthenticate(client,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostAllauthClientV1AuthWebauthnAuthenticateMutationResult = NonNullable<Awaited<ReturnType<typeof postAllauthClientV1AuthWebauthnAuthenticate>>>
    export type PostAllauthClientV1AuthWebauthnAuthenticateMutationBody = AuthenticateWebAuthnBody
    export type PostAllauthClientV1AuthWebauthnAuthenticateMutationError = ErrorResponse

    /**
 * @summary Perform 2FA using WebAuthn
 */
export const usePostAllauthClientV1AuthWebauthnAuthenticate = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AuthWebauthnAuthenticate>>, TError,{client: 'app' | 'browser';data: AuthenticateWebAuthnBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postAllauthClientV1AuthWebauthnAuthenticate>>,
        TError,
        {client: 'app' | 'browser';data: AuthenticateWebAuthnBody},
        TContext
      > => {

      const mutationOptions = getPostAllauthClientV1AuthWebauthnAuthenticateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Returns the WebAuthn credential request options, that can be
processed using `parseRequestOptionsFromJSON()` on the frontend.

 * @summary Get WebAuthn credential request options for login
 */
export const getAllauthClientV1AuthWebauthnLogin = (
    client: 'app' | 'browser',
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<WebAuthnRequestOptionsResponseResponse>(
      {url: `/_allauth/${client}/v1/auth/webauthn/login`, method: 'GET', signal
    },
      options);
    }
  

export const getGetAllauthClientV1AuthWebauthnLoginQueryKey = (client: 'app' | 'browser',) => {
    return [`/_allauth/${client}/v1/auth/webauthn/login`] as const;
    }

    
export const getGetAllauthClientV1AuthWebauthnLoginQueryOptions = <TData = Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnLogin>>, TError = unknown>(client: 'app' | 'browser', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnLogin>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllauthClientV1AuthWebauthnLoginQueryKey(client);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnLogin>>> = ({ signal }) => getAllauthClientV1AuthWebauthnLogin(client, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(client), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnLogin>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllauthClientV1AuthWebauthnLoginQueryResult = NonNullable<Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnLogin>>>
export type GetAllauthClientV1AuthWebauthnLoginQueryError = unknown


export function useGetAllauthClientV1AuthWebauthnLogin<TData = Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnLogin>>, TError = unknown>(
 client: 'app' | 'browser', options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnLogin>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnLogin>>,
          TError,
          Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnLogin>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllauthClientV1AuthWebauthnLogin<TData = Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnLogin>>, TError = unknown>(
 client: 'app' | 'browser', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnLogin>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnLogin>>,
          TError,
          Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnLogin>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllauthClientV1AuthWebauthnLogin<TData = Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnLogin>>, TError = unknown>(
 client: 'app' | 'browser', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnLogin>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get WebAuthn credential request options for login
 */

export function useGetAllauthClientV1AuthWebauthnLogin<TData = Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnLogin>>, TError = unknown>(
 client: 'app' | 'browser', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnLogin>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllauthClientV1AuthWebauthnLoginQueryOptions(client,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Login using a WebAuthn credential (Passkey). Both 200 and 401 can be
expected after a successful request.  The 401 can, for example, occur
when the credential passed was valid, but the email attached to the
account still requires verification.

 * @summary Login using WebAuthn
 */
export const postAllauthClientV1AuthWebauthnLogin = (
    client: 'app' | 'browser',
    loginWebAuthnBody: LoginWebAuthnBody,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<AuthenticatedResponse>(
      {url: `/_allauth/${client}/v1/auth/webauthn/login`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: loginWebAuthnBody, signal
    },
      options);
    }
  


export const getPostAllauthClientV1AuthWebauthnLoginMutationOptions = <TError = ErrorResponse | AuthenticationResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AuthWebauthnLogin>>, TError,{client: 'app' | 'browser';data: LoginWebAuthnBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AuthWebauthnLogin>>, TError,{client: 'app' | 'browser';data: LoginWebAuthnBody}, TContext> => {

const mutationKey = ['postAllauthClientV1AuthWebauthnLogin'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postAllauthClientV1AuthWebauthnLogin>>, {client: 'app' | 'browser';data: LoginWebAuthnBody}> = (props) => {
          const {client,data} = props ?? {};

          return  postAllauthClientV1AuthWebauthnLogin(client,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostAllauthClientV1AuthWebauthnLoginMutationResult = NonNullable<Awaited<ReturnType<typeof postAllauthClientV1AuthWebauthnLogin>>>
    export type PostAllauthClientV1AuthWebauthnLoginMutationBody = LoginWebAuthnBody
    export type PostAllauthClientV1AuthWebauthnLoginMutationError = ErrorResponse | AuthenticationResponse

    /**
 * @summary Login using WebAuthn
 */
export const usePostAllauthClientV1AuthWebauthnLogin = <TError = ErrorResponse | AuthenticationResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AuthWebauthnLogin>>, TError,{client: 'app' | 'browser';data: LoginWebAuthnBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postAllauthClientV1AuthWebauthnLogin>>,
        TError,
        {client: 'app' | 'browser';data: LoginWebAuthnBody},
        TContext
      > => {

      const mutationOptions = getPostAllauthClientV1AuthWebauthnLoginMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Returns the WebAuthn credential request options, that can be
processed using `parseRequestOptionsFromJSON()` on the frontend.

 * @summary Get WebAuthn credential request options for reauthentication
 */
export const getAllauthClientV1AuthWebauthnReauthenticate = (
    client: 'app' | 'browser',
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<WebAuthnRequestOptionsResponseResponse>(
      {url: `/_allauth/${client}/v1/auth/webauthn/reauthenticate`, method: 'GET', signal
    },
      options);
    }
  

export const getGetAllauthClientV1AuthWebauthnReauthenticateQueryKey = (client: 'app' | 'browser',) => {
    return [`/_allauth/${client}/v1/auth/webauthn/reauthenticate`] as const;
    }

    
export const getGetAllauthClientV1AuthWebauthnReauthenticateQueryOptions = <TData = Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnReauthenticate>>, TError = unknown>(client: 'app' | 'browser', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnReauthenticate>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllauthClientV1AuthWebauthnReauthenticateQueryKey(client);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnReauthenticate>>> = ({ signal }) => getAllauthClientV1AuthWebauthnReauthenticate(client, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(client), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnReauthenticate>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllauthClientV1AuthWebauthnReauthenticateQueryResult = NonNullable<Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnReauthenticate>>>
export type GetAllauthClientV1AuthWebauthnReauthenticateQueryError = unknown


export function useGetAllauthClientV1AuthWebauthnReauthenticate<TData = Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnReauthenticate>>, TError = unknown>(
 client: 'app' | 'browser', options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnReauthenticate>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnReauthenticate>>,
          TError,
          Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnReauthenticate>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllauthClientV1AuthWebauthnReauthenticate<TData = Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnReauthenticate>>, TError = unknown>(
 client: 'app' | 'browser', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnReauthenticate>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnReauthenticate>>,
          TError,
          Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnReauthenticate>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllauthClientV1AuthWebauthnReauthenticate<TData = Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnReauthenticate>>, TError = unknown>(
 client: 'app' | 'browser', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnReauthenticate>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get WebAuthn credential request options for reauthentication
 */

export function useGetAllauthClientV1AuthWebauthnReauthenticate<TData = Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnReauthenticate>>, TError = unknown>(
 client: 'app' | 'browser', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnReauthenticate>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllauthClientV1AuthWebauthnReauthenticateQueryOptions(client,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Reauthenticate the user using a WebAuthn credential.

 * @summary Reauthenticate using WebAuthn
 */
export const postAllauthClientV1AuthWebauthnReauthenticate = (
    client: 'app' | 'browser',
    reauthenticateWebAuthnBody: ReauthenticateWebAuthnBody,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<AuthenticatedResponse>(
      {url: `/_allauth/${client}/v1/auth/webauthn/reauthenticate`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: reauthenticateWebAuthnBody, signal
    },
      options);
    }
  


export const getPostAllauthClientV1AuthWebauthnReauthenticateMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AuthWebauthnReauthenticate>>, TError,{client: 'app' | 'browser';data: ReauthenticateWebAuthnBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AuthWebauthnReauthenticate>>, TError,{client: 'app' | 'browser';data: ReauthenticateWebAuthnBody}, TContext> => {

const mutationKey = ['postAllauthClientV1AuthWebauthnReauthenticate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postAllauthClientV1AuthWebauthnReauthenticate>>, {client: 'app' | 'browser';data: ReauthenticateWebAuthnBody}> = (props) => {
          const {client,data} = props ?? {};

          return  postAllauthClientV1AuthWebauthnReauthenticate(client,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostAllauthClientV1AuthWebauthnReauthenticateMutationResult = NonNullable<Awaited<ReturnType<typeof postAllauthClientV1AuthWebauthnReauthenticate>>>
    export type PostAllauthClientV1AuthWebauthnReauthenticateMutationBody = ReauthenticateWebAuthnBody
    export type PostAllauthClientV1AuthWebauthnReauthenticateMutationError = ErrorResponse

    /**
 * @summary Reauthenticate using WebAuthn
 */
export const usePostAllauthClientV1AuthWebauthnReauthenticate = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AuthWebauthnReauthenticate>>, TError,{client: 'app' | 'browser';data: ReauthenticateWebAuthnBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postAllauthClientV1AuthWebauthnReauthenticate>>,
        TError,
        {client: 'app' | 'browser';data: ReauthenticateWebAuthnBody},
        TContext
      > => {

      const mutationOptions = getPostAllauthClientV1AuthWebauthnReauthenticateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Returns the WebAuthn credential request options, that can be
processed using `parseRequestOptionsFromJSON()` on the frontend.

 * @summary Get passkey credential request options
 */
export const getAllauthClientV1AuthWebauthnSignup = (
    client: 'app' | 'browser',
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<WebAuthnRequestOptionsResponseResponse>(
      {url: `/_allauth/${client}/v1/auth/webauthn/signup`, method: 'GET', signal
    },
      options);
    }
  

export const getGetAllauthClientV1AuthWebauthnSignupQueryKey = (client: 'app' | 'browser',) => {
    return [`/_allauth/${client}/v1/auth/webauthn/signup`] as const;
    }

    
export const getGetAllauthClientV1AuthWebauthnSignupQueryOptions = <TData = Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnSignup>>, TError = ConflictResponse>(client: 'app' | 'browser', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnSignup>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllauthClientV1AuthWebauthnSignupQueryKey(client);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnSignup>>> = ({ signal }) => getAllauthClientV1AuthWebauthnSignup(client, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(client), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnSignup>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllauthClientV1AuthWebauthnSignupQueryResult = NonNullable<Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnSignup>>>
export type GetAllauthClientV1AuthWebauthnSignupQueryError = ConflictResponse


export function useGetAllauthClientV1AuthWebauthnSignup<TData = Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnSignup>>, TError = ConflictResponse>(
 client: 'app' | 'browser', options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnSignup>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnSignup>>,
          TError,
          Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnSignup>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllauthClientV1AuthWebauthnSignup<TData = Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnSignup>>, TError = ConflictResponse>(
 client: 'app' | 'browser', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnSignup>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnSignup>>,
          TError,
          Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnSignup>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllauthClientV1AuthWebauthnSignup<TData = Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnSignup>>, TError = ConflictResponse>(
 client: 'app' | 'browser', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnSignup>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get passkey credential request options
 */

export function useGetAllauthClientV1AuthWebauthnSignup<TData = Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnSignup>>, TError = ConflictResponse>(
 client: 'app' | 'browser', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnSignup>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllauthClientV1AuthWebauthnSignupQueryOptions(client,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * You initiate the passkey signup flow by inputting (`POST`) the required properties (e.g. email)
similar to the regular account signup, except that the `password` is to be left out.
The user will then be required to verify the email address, after which WebAuthn credential
creation options can be retrieved (`GET`) and used to actualy complete (`PUT`) the flow.

 * @summary Initiate the passkey signup flow
 */
export const postAllauthClientV1AuthWebauthnSignup = (
    client: 'app' | 'browser',
    passkeySignupBody: PasskeySignupBody,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/_allauth/${client}/v1/auth/webauthn/signup`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: passkeySignupBody, signal
    },
      options);
    }
  


export const getPostAllauthClientV1AuthWebauthnSignupMutationOptions = <TError = ErrorResponse | AuthenticationResponse | ForbiddenResponse | ConflictResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AuthWebauthnSignup>>, TError,{client: 'app' | 'browser';data: PasskeySignupBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AuthWebauthnSignup>>, TError,{client: 'app' | 'browser';data: PasskeySignupBody}, TContext> => {

const mutationKey = ['postAllauthClientV1AuthWebauthnSignup'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postAllauthClientV1AuthWebauthnSignup>>, {client: 'app' | 'browser';data: PasskeySignupBody}> = (props) => {
          const {client,data} = props ?? {};

          return  postAllauthClientV1AuthWebauthnSignup(client,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostAllauthClientV1AuthWebauthnSignupMutationResult = NonNullable<Awaited<ReturnType<typeof postAllauthClientV1AuthWebauthnSignup>>>
    export type PostAllauthClientV1AuthWebauthnSignupMutationBody = PasskeySignupBody
    export type PostAllauthClientV1AuthWebauthnSignupMutationError = ErrorResponse | AuthenticationResponse | ForbiddenResponse | ConflictResponse

    /**
 * @summary Initiate the passkey signup flow
 */
export const usePostAllauthClientV1AuthWebauthnSignup = <TError = ErrorResponse | AuthenticationResponse | ForbiddenResponse | ConflictResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAllauthClientV1AuthWebauthnSignup>>, TError,{client: 'app' | 'browser';data: PasskeySignupBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postAllauthClientV1AuthWebauthnSignup>>,
        TError,
        {client: 'app' | 'browser';data: PasskeySignupBody},
        TContext
      > => {

      const mutationOptions = getPostAllauthClientV1AuthWebauthnSignupMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Complete the passkey signup flow by handing over the WebAuthn credential.

 * @summary Complete the passkey signup flow
 */
export const putAllauthClientV1AuthWebauthnSignup = (
    client: 'app' | 'browser',
    addWebAuthnAuthenticatorBody: AddWebAuthnAuthenticatorBody,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<AuthenticatedResponse>(
      {url: `/_allauth/${client}/v1/auth/webauthn/signup`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: addWebAuthnAuthenticatorBody
    },
      options);
    }
  


export const getPutAllauthClientV1AuthWebauthnSignupMutationOptions = <TError = ErrorResponse | AuthenticationResponse | ConflictResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putAllauthClientV1AuthWebauthnSignup>>, TError,{client: 'app' | 'browser';data: AddWebAuthnAuthenticatorBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof putAllauthClientV1AuthWebauthnSignup>>, TError,{client: 'app' | 'browser';data: AddWebAuthnAuthenticatorBody}, TContext> => {

const mutationKey = ['putAllauthClientV1AuthWebauthnSignup'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putAllauthClientV1AuthWebauthnSignup>>, {client: 'app' | 'browser';data: AddWebAuthnAuthenticatorBody}> = (props) => {
          const {client,data} = props ?? {};

          return  putAllauthClientV1AuthWebauthnSignup(client,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutAllauthClientV1AuthWebauthnSignupMutationResult = NonNullable<Awaited<ReturnType<typeof putAllauthClientV1AuthWebauthnSignup>>>
    export type PutAllauthClientV1AuthWebauthnSignupMutationBody = AddWebAuthnAuthenticatorBody
    export type PutAllauthClientV1AuthWebauthnSignupMutationError = ErrorResponse | AuthenticationResponse | ConflictResponse

    /**
 * @summary Complete the passkey signup flow
 */
export const usePutAllauthClientV1AuthWebauthnSignup = <TError = ErrorResponse | AuthenticationResponse | ConflictResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putAllauthClientV1AuthWebauthnSignup>>, TError,{client: 'app' | 'browser';data: AddWebAuthnAuthenticatorBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof putAllauthClientV1AuthWebauthnSignup>>,
        TError,
        {client: 'app' | 'browser';data: AddWebAuthnAuthenticatorBody},
        TContext
      > => {

      const mutationOptions = getPutAllauthClientV1AuthWebauthnSignupMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * There are many configuration options that alter the functionality
and behavior of django-allauth, some of which can also impact the
frontend. Therefore, relevant configuration options are exposed via
this endpoint. The data returned is not user/authentication
dependent. Hence, it suffices to only fetch this data once at boot
time of your application.

 * @summary Get configuration
 */
export const getAllauthClientV1Config = (
    client: 'app' | 'browser',
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ConfigurationResponse>(
      {url: `/_allauth/${client}/v1/config`, method: 'GET', signal
    },
      options);
    }
  

export const getGetAllauthClientV1ConfigQueryKey = (client: 'app' | 'browser',) => {
    return [`/_allauth/${client}/v1/config`] as const;
    }

    
export const getGetAllauthClientV1ConfigQueryOptions = <TData = Awaited<ReturnType<typeof getAllauthClientV1Config>>, TError = unknown>(client: 'app' | 'browser', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1Config>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllauthClientV1ConfigQueryKey(client);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllauthClientV1Config>>> = ({ signal }) => getAllauthClientV1Config(client, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(client), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1Config>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllauthClientV1ConfigQueryResult = NonNullable<Awaited<ReturnType<typeof getAllauthClientV1Config>>>
export type GetAllauthClientV1ConfigQueryError = unknown


export function useGetAllauthClientV1Config<TData = Awaited<ReturnType<typeof getAllauthClientV1Config>>, TError = unknown>(
 client: 'app' | 'browser', options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1Config>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllauthClientV1Config>>,
          TError,
          Awaited<ReturnType<typeof getAllauthClientV1Config>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllauthClientV1Config<TData = Awaited<ReturnType<typeof getAllauthClientV1Config>>, TError = unknown>(
 client: 'app' | 'browser', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1Config>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllauthClientV1Config>>,
          TError,
          Awaited<ReturnType<typeof getAllauthClientV1Config>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllauthClientV1Config<TData = Awaited<ReturnType<typeof getAllauthClientV1Config>>, TError = unknown>(
 client: 'app' | 'browser', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1Config>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get configuration
 */

export function useGetAllauthClientV1Config<TData = Awaited<ReturnType<typeof getAllauthClientV1Config>>, TError = unknown>(
 client: 'app' | 'browser', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1Config>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllauthClientV1ConfigQueryOptions(client,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




